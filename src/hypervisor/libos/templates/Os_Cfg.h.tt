<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
/*
 * Os_Cfg.h -- AUTOGENERATED -- DO NOT EDIT --
 */

#ifndef OS_CFG_H
#define OS_CFG_H

#include <Os_Types.h>
<#
	string part_name = config.LookupValues("OSEKPartition");

	List<XPathNavigator> partitionlist = config.Select("/system/partition[@name = '"+part_name+"']");
	if (partitionlist.Count != 1)
	{
		throw new Exception("error: can't identify a partition named '"+part_name+"'!");
	}

	XPathNavigator partition = partitionlist[0];
	int id = 0; 
#>

/* generated ids for OSEK OS objects in partition '<#=part_name#>' */

/* OSEK task ids */
<#
	foreach (XPathNavigator task in partition.Select("task"))
	{
		XPathNodeIterator osekiterator = task.Select("osek");
		if (osekiterator.MoveNext())
		{
			/* this is an OSEK task, generate a define for its name */
#>
#define <#=task.GetAttribute("name","")#> <#=id#>
<#
		}
		/* count *all* tasks */
		id++;
	}
#>

/* OSEK ISR ids */
<#
	foreach (XPathNavigator isr in partition.Select("isr"))
	{
		XPathNodeIterator osekiterator = isr.Select("osek");
		if (osekiterator.MoveNext())
		{
			/* this is an OSEK ISR, generate a define for its name */
#>
#define <#=isr.GetAttribute("name","")#> <#=id#>
<#
		}
		id++;
	}
#>

/* hooks (only used internally) */
<#
	foreach (XPathNavigator hook in partition.Select("hook"))
	{
#>
#define OSEK_ID_<#=hook.GetAttribute("name","")#> <#=id#>
<#
		id++;
	}
#>

/* counter ids */
<#
	id = 0;
	foreach (XPathNavigator counter_access in partition.Select("counter_access"))
	{
#>
#define <#=counter_access.GetAttribute("counter","")#> <#=id#>
<#
		id++;
	}
#>

/* alarm ids */
<#
	id = 0;
	foreach (XPathNavigator alarm in partition.Select("alarm"))
	{
#>
#define <#=alarm.GetAttribute("name","")#> <#=id#>
<#
		id++;
	}
#>

/* schedule table ids */
<#
	id = 0;
	foreach (XPathNavigator schedule in partition.Select("sched_table"))
	{
#>
#define <#=schedule.GetAttribute("name","")#> <#=id#>
<#
		id++;
	}
#>

/* resource ids */
<#
	id = 0;
	foreach (XPathNavigator resource in partition.Select("resource"))
	{
#>
#define <#=resource.GetAttribute("name","")#> <#=id#>
<#
		id++;
	}
#>

/* event masks */

<#
	/* Dictionary that stores usable event bits for each task */
	Dictionary<string,uint> FreeEventBits = new Dictionary<string,uint>();

	foreach (XPathNavigator task in partition.Select("task[@blocking='yes']"))
	{
		FreeEventBits.Add(task.GetAttribute("name",""), 0xFFFFFFFFu);
	}
#>
/* events with fixed masks */
<#
	/* now define fixed events and allocate them to tasks */
	foreach (XPathNavigator fixedevent in partition.Select("event[@mask]"))
	{
		uint mask = UInt32.Parse(fixedevent.GetAttribute("mask",""));
		string eventname = fixedevent.GetAttribute("name","");
		string usedbystring = "";

		foreach (XPathNavigator task in partition.Select("task[(@blocking='yes') and (osek/eventaccess/@event = '"+eventname+"')]"))
		{
			string taskname = task.GetAttribute("name","");
			if ((FreeEventBits[taskname] & mask) != mask)
			{
				throw new Exception("error: event '"+eventname+"': mask '"+mask+"' not available for task '"+taskname+"'!");
			} else {
				FreeEventBits[taskname] &= (~ mask);
				usedbystring += " " + taskname;
			}
		}
		if (usedbystring == "")
		{
			usedbystring = "not used by any task";
		}
		else
		{
			usedbystring = "used by task(s):" + usedbystring;
		}
#>
#define <#=eventname#>  0x<#=mask.ToString("X")#> /* <#=usedbystring#> */
<#
	}
#>
/* events with automatically assigned masks */
<#
	/* now allocate masks for AUTO events */
	foreach (XPathNavigator autoevent in partition.Select("event[not(@mask)]"))
	{
		string eventname = autoevent.GetAttribute("name","");
		uint bitsavailable = 0xFFFFFFFFu;
		List<string> usedbytasks = new List<string>();
		string usedbystring = "";

		foreach (XPathNavigator task in partition.Select("task[@blocking='yes' and osek/eventaccess/@event = '"+eventname+"']"))
		{
			string taskname = task.GetAttribute("name","");
			usedbytasks.Add(taskname);
			bitsavailable &= FreeEventBits[taskname];
			usedbystring += " " + taskname;
		}

		if (usedbystring == "")
		{
			usedbystring = "not used by any task";
		}
		else
		{
			usedbystring = "used by task(s):" + usedbystring;
		}

		if (bitsavailable == 0)
		{
			throw new Exception("error: can't allocate mask for event '"+eventname+"' "+usedbystring);
		}
		uint mask;
		for (mask = 1; (bitsavailable & mask) == 0; mask <<= 1)
		{
			/* search lowest bit set */
		}
#>
#define <#=eventname#>  0x<#=mask.ToString("X")#> /* <#=usedbystring#> */
<#
		/* mark this event mask as taken in all tasks using it */
		foreach (string taskname in usedbytasks)
		{
			FreeEventBits[taskname] &= (~ mask);
		}
	}

	/* FIXME: add error checks for invalid event references */
#>

/* application modes */

<#
	List<string> appmodelist = new List<string>();

	foreach (XPathNavigator appmode in partition.Select("appmode"))
	{
		appmodelist.Add(appmode.GetAttribute("name",""));
	}

	if (appmodelist.Count == 0)
	{
		appmodelist.Add("OSDEFAULTAPPMODE");
	}

	appmodelist.Sort();
	id = 0;

	foreach (string appmode in appmodelist)
	{
#>
#define <#=appmode#> <#=id#>
<#
		id++;
	}
#>

/* prototypes */

<#
	foreach (XPathNavigator task in partition.Select("task"))
	{
		XPathNodeIterator osekiterator = task.Select("osek");
		if (osekiterator.MoveNext())
		{
#>
extern void _Task_<#=task.GetAttribute("name","")#>(void);
<#
		}
	}

	foreach (XPathNavigator isr in partition.Select("isr"))
	{
		XPathNodeIterator osekiterator = isr.Select("osek");
		if (osekiterator.MoveNext())
		{
#>
extern void _Isr_<#=isr.GetAttribute("name","")#>(void);
<#
		}
	}
#>

/* FIXME: TODO ... */

#endif /* OS_CFG_H */
