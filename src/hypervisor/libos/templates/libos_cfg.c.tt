<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
/* libos_cfg.c -- AUTOGENERATED -- DO NOT EDIT -- */

#include <hv.h>
#include <stdio.h>
#include <linker.h>
#include <hv_compiler.h>

#include <Os_Types.h>
#include <Os_Cfg.h>
#include <Os_PrivateCfg.h>

<#
	string part_name = config.LookupValues("OSEKPartition");

	List<XPathNavigator> partitionlist = config.Select("/system/partition[@name = '"+part_name+"']");
	if (partitionlist.Count != 1)
	{
		throw new Exception("error: can't identify a partition named '"+part_name+"'!");
	}

	XPathNavigator partition = partitionlist[0];
#>
/* generated code for OSEK library in partition '<#=part_name#>' */

/* resources */

<#
	int numresources = partition.Select("resource").Count;
	int numtasks2 = partition.Select("task").Count;
	int numtasksorisrs = partition.Select("task").Count + partition.Select("isr").Count;
	int numtasksorisrsorhooks = partition.Select("task").Count + partition.Select("isr").Count + partition.Select("hook").Count;
#>
const uint8 Os_firstISRID = <#=numtasks2#>;
const uint8 Os_firstHookID = <#=numtasksorisrs#>;

const uint8 Os_numResources = <#=numresources#>;

ResourceType Os_lastResTaken[<#=numtasksorisrsorhooks#>] =
{
<#
		for (int i = 0; i < numtasksorisrsorhooks; i++)
		{
#>
	INVALID_RESOURCE,
<#
		}
#>
};
<#
	if (numresources > 0)
	{
#>
Os_ResourceData_t Os_ResourceData[<#=numresources#>] =
{
<#
		foreach (XPathNavigator resource in partition.Select("resource"))
		{
#>
	{ /* <#=resource.GetAttribute("name","")#> */
		.lockedBy = INVALID_TASK,
		.prevResource = INVALID_RESOURCE,
		.prio = <#=resource.GetAttribute("prio","")#>,
		.oldPrio = 0,
	},
<#
		}
#>
};
<#
	} else {
#>

Os_ResourceData_t Os_ResourceData[1]; /* dummy array for linking */
<#
	} /* if resources */
#>

/* hooks */

<#
	List<string> hooklist = new List<string>();

	foreach (XPathNavigator hook in partition.Select("hook[osek]"))
	{
		hooklist.Add(hook.GetAttribute("name", ""));
	}
#>
const Os_HookConfig_t Os_HookConfig =
{
<#
	if (hooklist.Contains("StartupHook"))
	{
#>
	.startuphook = OSEK_ID_StartupHook,
<#
	} else {
#>
	.startuphook = INVALID_TASK,
<#
	}
	if (hooklist.Contains("ErrorHook"))
	{
#>
	.errorhook = OSEK_ID_ErrorHook,
<#
	} else {
#>
	.errorhook = INVALID_TASK,
<#
	}
#>
};

/* autostarts */
<#
	List<string> appmodelist = new List<string>();

	foreach (XPathNavigator appmode in partition.Select("appmode"))
	{
		appmodelist.Add(appmode.GetAttribute("name",""));
	}

	if (appmodelist.Count == 0)
	{
		appmodelist.Add("OSDEFAULTAPPMODE");
	}

	appmodelist.Sort();

	Dictionary<string,int[]> appmodeconfig = new Dictionary<string,int[]>();

	foreach (string appmode in appmodelist)
	{
		string autostartselect = "/osek/autostart[@appmode = '"+appmode+"']";
		XPathNodeIterator alarmiterator = partition.Select("alarm"+autostartselect);
		int numalarms = alarmiterator.Count;
		if (numalarms > 0)
		{
#>
static const Os_AutoStartAlarm_t AutoStartAlarm_<#=appmode#>[<#=numalarms#>] =
{
<#
			foreach (XPathNavigator alarmautostart in alarmiterator)
			{
				XPathNodeIterator ai = alarmautostart.Select("../..");
				ai.MoveNext();
#>
	{
		.id = <#=ai.Current.GetAttribute("name", "")#>,
		.alarmtime = <#=alarmautostart.GetAttribute("alarmtime", "")#>,
		.cycletime = <#=alarmautostart.GetAttribute("cycletime", "")#>,
<#
				if (alarmautostart.GetAttribute("relative", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
				{
#>
		.isrelative = 1,
<#
				} else {
#>
		.isrelative = 0,
<#
				}
#>
	},
<#
			} /* foreach alarmautostart */
#>
};
<#
		} /* if numalarms */

		XPathNodeIterator scheduleiterator = partition.Select("sched_table"+autostartselect);
		int numschedules = scheduleiterator.Count;
		if (numschedules > 0)
		{
#>
static const Os_AutoStartSchedule_t AutoStartSchedule_<#=appmode#>[<#=numschedules#>] =
{
<#
			foreach (XPathNavigator scheduleautostart in scheduleiterator)
			{
				XPathNodeIterator si = scheduleautostart.Select("../..");
				si.MoveNext();
#>
	{
		.id = <#=si.Current.GetAttribute("name", "")#>,
		.startvalue = <#=scheduleautostart.GetAttribute("startvalue", "")#>,
		.startmode = OS_SCHEDAUTOMODE_<#=scheduleautostart.GetAttribute("startmode", "").ToUpper()#>,
	},
<#
			} /* foreach scheduleautostart */
#>
};
<#
		} /* if numschedules */

		XPathNodeIterator taskiterator = partition.Select("task"+autostartselect);
		int numtasks = taskiterator.Count;
		if (numtasks > 0)
		{
#>
static const Os_AutoStartTask_t AutoStartTask_<#=appmode#>[<#=numtasks#>] =
{
<#
			foreach (XPathNavigator taskautostart in taskiterator)
			{
				XPathNodeIterator ti = taskautostart.Select("../..");
				ti.MoveNext();
#>
	{
		.id = <#=ti.Current.GetAttribute("name", "")#>,
	},
<#
			} /* foreach taskautostart */
#>
};
<#
		} /* if numtasks */
		appmodeconfig[appmode] = new int[]{ numalarms, numschedules, numtasks};


	} /* foreach appmode */

#>
const uint8 Os_numAppmodes = <#=appmodelist.Count#>;

const Os_AppmodeConfig_t Os_AppmodeConfig[<#=appmodelist.Count#>] =
{
<#
	foreach (string appmode in appmodelist)
	{
#>
	{ /* <#=appmode#> */
<#
		int numalarms = appmodeconfig[appmode][0];
		int numschedules = appmodeconfig[appmode][1];
		int numtasks = appmodeconfig[appmode][2];
		if (numalarms > 0)
		{
#>
		.alarms = &AutoStartAlarm_<#=appmode#>[0],
<#
		} else {
#>
		.alarms = 0, /* no autostart alarms */
<#
		} /* if numalarms */
		if (numschedules > 0)
		{
#>
		.schedules = &AutoStartSchedule_<#=appmode#>[0],
<#
		} else {
#>
		.schedules = 0, /* no autostart schedule tables */
<#
		} /* if numschedules */
		if (numtasks > 0)
		{
#>
		.tasks = &AutoStartTask_<#=appmode#>[0],
<#
		} else {
#>
		.tasks = 0, /* no autostart tasks */
<#
		} /* if numtasks */
#>
		.numalarms = <#=numalarms#>,
		.numschedules = <#=numschedules#>,
		.numtasks = <#=numtasks#>,
	},
<#
	} /* foreach appmode */
#>
};

/* generated stacks */
<#
	List<string> stacklist = new List<string>();
	Dictionary<string,Int32> stacksizes = new Dictionary<string,Int32>();
	Dictionary<string,string> stackusers = new Dictionary<string,string>();

	/* stack for OSEK library - FIXME: won't work for nested hooks - rework for ErrorHook/ProtectionHook */
	int osekstacksize = 200; /* FIXME: hardcoded */
	foreach (XPathNavigator hook in partition.Select("hook"))
	{
		/* XPathNodeIterator osekiterator = hook.Select("osek"); */
		/* if (osekiterator.MoveNext()) */

        XPathNodeIterator invokeiterator = hook.Select("invoke");
        if (invokeiterator.MoveNext())
		{
			/* this is an OSEK hook */
			/* int hookstacksize = Convert.ToInt32(osekiterator.Current.GetAttribute("stacksize","")); */
			int hookstacksize = Convert.ToInt32(invokeiterator.Current.GetAttribute("stack_size",""));
			if (osekstacksize < hookstacksize)
			{
				osekstacksize = hookstacksize;
			}
		}
	}
	stacklist.Add("__libosstack");
	stacksizes.Add("__libosstack", osekstacksize);
	stackusers.Add("__libosstack", "[OSEK library] ");

	/* task/ISR stacks */

	/* this assumes that stack definitions always have the format "<symbol>", with
	 * "<symbol>" being the symbol we need to define, e.g. "__stack0".
	 * FIXME: check that the format is as expected */
	/* FIXME: need A LOT of error checking here! */
	foreach (XPathNavigator taskorisr in partition.Select("task | isr"))
	{
		XPathNodeIterator osekiterator = taskorisr.Select("osek");
		if (osekiterator.MoveNext())
		{
			/* this is an OSEK task/ISR */
			XPathNavigator osek = osekiterator.Current;
			XPathNodeIterator invokeiterator = taskorisr.Select("invoke");
			if (! invokeiterator.MoveNext())
			{
				/* FIXME: error handling! */
			}
			XPathNavigator invoke = invokeiterator.Current;

			string stack = invoke.GetAttribute("stack","");
			if (!stacklist.Contains(stack))
			{
				stacklist.Add(stack);
			}

			/* Int32 stacksize = Convert.ToInt32(osek.GetAttribute("stacksize","")); */
            Int32 stacksize = Convert.ToInt32(invoke.GetAttribute("stack_size",""));
			if (! stacksizes.ContainsKey(stack))
			{
				stacksizes.Add(stack, stacksize);
			}
			else
			{
				if (stacksizes[stack] < stacksize)
				{
					stacksizes[stack] = stacksize;
				}
			}
			if (! stackusers.ContainsKey(stack))
			{
				stackusers.Add(stack, "used by: " + taskorisr.GetAttribute("name","") + " ");
			}
			else
			{
				stackusers[stack] += taskorisr.GetAttribute("name","") + " ";
			}
		}
	}
	foreach (string stack in stacklist)
	{
#>
struct { /* <#=stackusers[stack]#>*/
	uint32_t s[<#=stacksizes[stack]#>];
} <#=stack#> __aligned(16) __section(.bss.stack);

<#
	}
#>

const uint8 Os_numStacks = <#=stacklist.Count#>;
const Os_StackConfig_t Os_StackConfig[<#=stacklist.Count#>] =
{
<#
	foreach (string stack in stacklist)
	{
#>
	{ /* <#=stackusers[stack]#>*/
		.stack = (uint32 *) &<#=stack#>,
		.size = <#=stacksizes[stack]#>,
	},
<#
	}
#>
};

/** exception data (accessed by kernel) */
user_exception_state_t _os_exception_state __section(.sbss.kernel_shared);

/** error data array (accessed by kernel) */
// FIXME: hard-coded array size below, derive from "error_records" attribute?
// FIXME: partition.GetAttribute("error_records", "") ??
#define OS_NUM_ERRORS 4
const uint8 _os_num_errors = OS_NUM_ERRORS;
user_error_state_t _os_error_state[OS_NUM_ERRORS] __section(.sbss.kernel_shared);
