#!/usr/bin/perl -w
#
# ab_gen_lddefines.pl - generate linker includes for relocation
#
# NOTE: requires the XML::Simple CPAN module
#       on Ubuntu 12.04, try:  sudo apt-get install libxml-simple-perl
#
# Usage: ab_gen_lddefines.pl [-m memory.xml] system.xml
# Without the memory map, this script assumes dummy addresses for RAM and ROM.
#
# azuepke, 2015-06-26: clone from ab_gen_ldscripts.pl
# azuepke, 2015-11-24: emit addresses of SHMs as well
# azuepke, 2016-01-29: generate include guards


use strict;
use warnings "all";
use XML::Simple;
use Data::Dumper;

# tool version ID
my $VERSION = "ab_gen_lddefines.pl 2016-01-29";

# global variables
my $verbose = 0;
my %addrhash;
my %sizehash;


################################################################################

# Evaluate hex or decimal number
sub number
{
	$_ = shift;
	if (substr ($_, 0, 2) eq '0x') {
		return hex $_;
	}
	return int $_;
}

# Return hex string of argument
sub hexify
{
	return sprintf("0x%08x", shift);
}

################################################################################

sub usage
{
	my $ret = shift;
	if (!defined $ret) {
		$ret = 1;
	}

	print "usage:\n";
	print "  ab_gen_lddefines.pl [-h|--help] [--version]\n";
	print "                      [-v]\n";
	print "                      [-m <memory.xml>]\n";
	print "                      <system.xml>\n";
	print "\n";
	print "options:\n";
	print "  -h|--help       print this help text and exit\n";
	print "  --version       print version information and exit\n";
	print "  -v              verbosity level, increases for each -v\n";
	print "  -m <memory.xml> Use correct memory map for linker addresses\n";
	print "  -p <directory>  path to application\n";
	print "  <system.xml>    system description\n";
	print "\n";
	print "note:\n";
	print "  The linker includes use dummy addresses if no memory map is supplied!\n";

	exit $ret;
}

################################################################################

my $sysxmlfile;
my $memxmlfile;
my $appdir = '.';

while (defined $ARGV[0]) {
	if ($ARGV[0] eq '--help') {
		usage(0);
	} elsif ($ARGV[0] eq '-h') {
		usage(0);
	} elsif ($ARGV[0] eq '--version') {
		print "version: ", $VERSION, "\n";
		exit 0;
	} elsif ($ARGV[0] eq '-v') {
		shift;
		$verbose++;
	} elsif ($ARGV[0] eq '-m') {
		shift;
		$memxmlfile = shift;
	} elsif ($ARGV[0] eq '-p') {
		shift;
		$appdir = shift;
	} else {
		if (defined $sysxmlfile) {
			die "error: invalid argument '", $ARGV[0], "'\n";
		}
		$sysxmlfile = shift;
	}
}

if (!defined $sysxmlfile) {
	die "error: no xml-file specified\n";
}


if (defined $memxmlfile) {
	# read memory.xml
	my $mem = XMLin($memxmlfile,
					KeyAttr => { },
					ForceArray => ['shm', 'part', 'task', 'rq'],
					) or die "opening and parsing of '$memxmlfile' failed!\n";

	# iterate partitions, remember start address of all rqs
	for my $part (@{$mem->{part}}) {
		my $partname = $part->{name};

		for my $rq (@{$part->{rq}}) {
			my $rqname = $rq->{name};
			if (!defined $rq->{start} || !defined $rq->{size}) {
				die "error: memory.xml does not contain final addresses\n";
			}

			my $start = number $rq->{start};
			my $size = number $rq->{size};
			if ($verbose) {
				print "part '$partname' rq '$rqname' start ", hexify($start), " size ", hexify($size), "\n";
			}
			$addrhash{$partname."::".$rqname} = $start;
			$sizehash{$partname."::".$rqname} = $size;
		}
	}
}


my $all = XMLin($sysxmlfile,
				KeyAttr => { },
				ForceArray => ['layout', 'section', 'partition', 'shm_access'],
				) or die "opening and parsing of '$sysxmlfile' failed!\n";

my $sys = $all->{system};

# iterate partitions and get all sections
for my $part (@{$sys->{partition}}) {
	my $partname = $part->{name};

	my $layout = $part->{layout}[0];
	if (!defined $layout->{ldh}) {
		die "error: 'ldh'-attribute not found in partition's '", $partname, "' <layout> config.xml\n";
	}
	my $ldh_file = $appdir . "/" . $layout->{ldh};

	if ($verbose) {
		print "part '$partname' ldh '$ldh_file'\n";
	}

	open(my $OUTFILE, ">$ldh_file") or die "Can't create linker script $ldh_file: $!";
	print $OUTFILE "/* NOTE -- generated by scripts/ab_gen_lddefines.pl -- DO NOT EDIT */\n";
	print $OUTFILE "/* ", $VERSION, " */\n";
	if ($memxmlfile) {
		print $OUTFILE "/* NOTE: this file contains the final relocation information */\n";
	} else {
		print $OUTFILE "/* WARNING: THIS FILE LACKS THE FINAL RELOCATION INFORMATION */\n";
	}
	print $OUTFILE "\n";

	print $OUTFILE "#ifndef __LDS_", $partname, "__\n";
	print $OUTFILE "#define __LDS_", $partname, "__\n";
	print $OUTFILE "\n";

	if (!defined $layout->{section}) {
		die "error: <section> not found in partition's '", $partname, "' <layout> config.xml\n";
	}

	my $dummy_start = 0x20000000;
	for my $section (@{$layout->{section}}) {
		my $name = $section->{name};

		my $start;
		my $size;
		if ($memxmlfile) {
			$start = $addrhash{$partname."::".$name};
			$size = $sizehash{$partname."::".$name};
		} else {
			$start = $dummy_start;
			$size = 0x01000000;
			$dummy_start += 0x10000000;
		}

		if ($verbose) {
			print "part '$partname' section '$name' start ", hexify($start), " size ", hexify($size), "\n";
		}
		print $OUTFILE "#define SECTION_START_", $name, "\t", hexify($start), "\n";
		print $OUTFILE "#define SECTION_SIZE_", $name, "\t", hexify($size), "\n";
	}

	# iterate SHMs as well
	for my $shm (@{$part->{shm_access}}) {
		my $name = $shm->{shm};

		my $start;
		my $size;
		if ($memxmlfile) {
			$start = $addrhash{$partname."::".$name};
			$size = $sizehash{$partname."::".$name};
		} else {
			$start = $dummy_start;
			$size = 0x01000000;
			$dummy_start += 0x10000000;
		}

		if ($verbose) {
			print "part '$partname' shm '$name' start ", hexify($start), " size ", hexify($size), "\n";
		}
		print $OUTFILE "#define SHM_START_", $name, "\t", hexify($start), "\n";
		print $OUTFILE "#define SHM_SIZE_", $name, "\t", hexify($size), "\n";
	}

	print $OUTFILE "\n";
	print $OUTFILE "#endif\n";

	close($OUTFILE) or die "Can't close $ldh_file: $!";
}
