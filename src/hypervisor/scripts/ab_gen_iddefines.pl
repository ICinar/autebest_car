#!/usr/bin/perl -w
#
# ab_gen_iddefines.pl - generate include with partition specific IDs
#
# NOTE: requires the XML::Simple CPAN module
#       on Ubuntu 12.04, try:  sudo apt-get install libxml-simple-perl
#
# Usage: ab_gen_iddefines.pl system.xml
#
# azuepke, 2015-11-24: initial, cloned from ab_gen_lddefines.pl
# azuepke, 2016-01-13: added RPC hooks
# azuepke, 2016-01-29: generate include guards


use strict;
use warnings "all";
use XML::Simple;
use Data::Dumper;

# tool version ID
my $VERSION = "ab_gen_iddefines.pl 2016-01-29";

# global variables
my $verbose = 0;


################################################################################

# Evaluate hex or decimal number
sub number
{
	$_ = shift;
	if (substr ($_, 0, 2) eq '0x') {
		return hex $_;
	}
	return int $_;
}

# Return hex string of argument
sub hexify
{
	return sprintf("0x%08x", shift);
}

################################################################################

sub usage
{
	my $ret = shift;
	if (!defined $ret) {
		$ret = 1;
	}

	print "usage:\n";
	print "  ab_gen_iddefines.pl [-h|--help] [--version]\n";
	print "                      [-v]\n";
	print "                      <system.xml>\n";
	print "\n";
	print "options:\n";
	print "  -h|--help       print this help text and exit\n";
	print "  --version       print version information and exit\n";
	print "  -v              verbosity level, increases for each -v\n";
	print "  -p <directory>  path to application\n";
	print "  <system.xml>    system description\n";
	print "\n";

	exit $ret;
}

################################################################################

my $sysxmlfile;
my $appdir = '.';

while (defined $ARGV[0]) {
	if ($ARGV[0] eq '--help') {
		usage(0);
	} elsif ($ARGV[0] eq '-h') {
		usage(0);
	} elsif ($ARGV[0] eq '--version') {
		print "version: ", $VERSION, "\n";
		exit 0;
	} elsif ($ARGV[0] eq '-v') {
		shift;
		$verbose++;
	} elsif ($ARGV[0] eq '-p') {
		shift;
		$appdir = shift;
	} else {
		if (defined $sysxmlfile) {
			die "error: invalid argument '", $ARGV[0], "'\n";
		}
		$sysxmlfile = shift;
	}
}

if (!defined $sysxmlfile) {
	die "error: no xml-file specified\n";
}


my $all = XMLin($sysxmlfile,
				KeyAttr => { },
				ForceArray => ['partition', 'layout', 'hook', 'task', 'isr',
				               'kldd', 'ipev', 'counter_access', 'shm_access',
				               'rpc', 'invokable',
				               'alarm', 'wait_queue', 'sched_table'],
				) or die "opening and parsing of '$sysxmlfile' failed!\n";

my $sys = $all->{system};

# iterate partitions and get all sections
my $part_id = 0;
for my $part (@{$sys->{partition}}) {
	my $partname = $part->{name};

	my $layout = $part->{layout}[0];
	if (!defined $layout->{idh}) {
		if ($verbose) {
			print "part '$partname' no idh-attribute found, skipped\n";
		}
		$part_id++;
		next;
	}

	my $idh_file = $appdir . "/" . $layout->{idh};

	if ($verbose) {
		print "part '$partname' idh '$idh_file'\n";
	}

	open(my $OUTFILE, ">$idh_file") or die "Can't create id include $idh_file: $!";
	print $OUTFILE "/* NOTE -- generated by scripts/ab_gen_iddefines.pl -- DO NOT EDIT */\n";
	print $OUTFILE "/* ", $VERSION, " */\n";
	print $OUTFILE "\n";

	print $OUTFILE "#ifndef __IDS_", $partname, "__\n";
	print $OUTFILE "#define __IDS_", $partname, "__\n";
	print $OUTFILE "\n";

	# general partition attributes
	print $OUTFILE "#define CFG_PART_NAME\t", $partname, "\n";
	print $OUTFILE "#define CFG_PART_NAME_STR\t\"", $partname, "\"\n";
	print $OUTFILE "#define CFG_PART_ID\t", $part_id, "\n";
	print $OUTFILE "#define CFG_MAX_PRIO\t", $part->{max_prio}, "\n";
	my $cpu = 0;
	if (defined $part->{cpu}) {
		$cpu = $part->{cpu};
	}
	print $OUTFILE "#define CFG_PART_CPU\t", $cpu, "\n";

	my $timepart = 0;
	if (defined $part->{timepart}) {
		$timepart = $part->{timepart};
	}
	print $OUTFILE "#define CFG_PART_TIMEPART\t", $timepart, "\n";

	if (defined $part->{error_records}) {
		print $OUTFILE "#define CFG_NUM_ERROR_RECORDS\t", $part->{error_records}, "\n";
	} else {
		print $OUTFILE "/* CFG_NUM_ERROR_RECORDS not defined */\n";
	}
	print $OUTFILE "\n";

	# iterate tasks
	my $task_id = 0;
	for my $task (@{$part->{task}}) {
		my $name = $task->{name};
		print $OUTFILE "#define CFG_TASK_", $name, "\t", $task_id, "\n";
		my $prio = $task->{prio};
		print $OUTFILE "#define CFG_TASK_", $name, "_PRIO\t", $prio, "\n";
		$task_id++;
	}
	print $OUTFILE "#define CFG_NUM_TASKS\t", $task_id, "\n";
	print $OUTFILE "\n";

	# isrs
	my $first_isr_id = $task_id;
	for my $isr (@{$part->{isr}}) {
		my $name = $isr->{name};
		print $OUTFILE "#define CFG_ISR_", $name, "\t", $task_id, "\n";
		my $prio = $isr->{prio};
		print $OUTFILE "#define CFG_ISR_", $name, "_PRIO\t", $prio, "\n";
		$task_id++;
	}
	print $OUTFILE "#define CFG_NUM_ISRS\t", $task_id - $first_isr_id, "\n";
	print $OUTFILE "\n";

	# hooks
	my $first_hook_id = $task_id;
	my $init_hook_id = -1;
	my $error_hook_id = -1;
	my $exception_hook_id = -1;
	for my $hook (@{$part->{hook}}) {
		my $name = $hook->{name};

		# remember special task IDs for later
		if (defined $part->{init_hook} && $part->{init_hook} eq $name) {
			$init_hook_id = $task_id;
		}
		if (defined $part->{error_hook} && $part->{error_hook} eq $name) {
			$error_hook_id = $task_id;
		}
		if (defined $part->{exception_hook} && $part->{exception_hook} eq $name) {
			$exception_hook_id = $task_id;
		}

		print $OUTFILE "#define CFG_HOOK_", $name, "\t", $task_id, "\n";
		my $prio = $hook->{prio};
		print $OUTFILE "#define CFG_HOOK_", $name, "_PRIO\t", $prio, "\n";
		$task_id++;
	}
	print $OUTFILE "#define CFG_NUM_HOOKS\t", $task_id - $first_hook_id, "\n";
	print $OUTFILE "\n";

	# IDs of special hooks
	if ($init_hook_id != -1) {
		print $OUTFILE "#define CFG_INIT_HOOK_ID\t", $init_hook_id, "\n";
	} else {
		print $OUTFILE "/* CFG_INIT_HOOK_ID not defined */\n";
	}
	if ($error_hook_id != -1) {
		print $OUTFILE "#define CFG_ERROR_HOOK_ID\t", $error_hook_id, "\n";
	} else {
		print $OUTFILE "/* CFG_ERROR_HOOK_ID not defined */\n";
	}
	if ($exception_hook_id != -1) {
		print $OUTFILE "#define CFG_EXCEPTION_HOOK_ID\t", $exception_hook_id, "\n";
	} else {
		print $OUTFILE "/* CFG_EXCEPTION_HOOK_ID not defined */\n";
	}
	print $OUTFILE "\n";

	# RPC invokables
	my $first_invokable_id = $task_id;
	for my $invokable (@{$part->{invokable}}) {
		my $name = $invokable->{name};

		print $OUTFILE "#define CFG_INVOKABLE_", $name, "\t", $task_id, "\n";
		my $prio = $invokable->{prio};
		print $OUTFILE "#define CFG_INVOKABLE_", $name, "_PRIO\t", $prio, "\n";
		$task_id++;
	}
	print $OUTFILE "#define CFG_NUM_INVOKABLES\t", $task_id - $first_invokable_id, "\n";
	print $OUTFILE "\n";

	# iterate RPCs
	my $rpc_id = 0;
	for my $rpc (@{$part->{rpc}}) {
		my $name = $rpc->{name};
		print $OUTFILE "#define CFG_RPC_", $name, "\t", $rpc_id, "\n";
		$rpc_id++;
	}
	print $OUTFILE "#define CFG_NUM_RPCS\t", $rpc_id, "\n";
	print $OUTFILE "\n";

	# iterate SHMs
	my $shm_id = 0;
	for my $shm (@{$part->{shm_access}}) {
		my $name = $shm->{shm};
		print $OUTFILE "#define CFG_SHM_", $name, "\t", $shm_id, "\n";
		$shm_id++;
	}
	print $OUTFILE "#define CFG_NUM_SHMS\t", $shm_id, "\n";
	print $OUTFILE "\n";

	# iterate kldds
	my $kldd_id = 0;
	for my $kldd (@{$part->{kldd}}) {
		my $name = $kldd->{name};
		print $OUTFILE "#define CFG_KLDD_", $name, "\t", $kldd_id, "\n";
		$kldd_id++;
	}
	print $OUTFILE "#define CFG_NUM_KLDDS\t", $kldd_id, "\n";
	print $OUTFILE "\n";

	# iterate IPEVs
	my $ipev_id = 0;
	for my $ipev (@{$part->{ipev}}) {
		my $name = $ipev->{name};
		print $OUTFILE "#define CFG_IPEV_", $name, "\t", $ipev_id, "\n";
		$ipev_id++;
	}
	print $OUTFILE "#define CFG_NUM_IPEVS\t", $ipev_id, "\n";
	print $OUTFILE "\n";

	# iterate counters
	my $counter_id = 0;
	for my $counter (@{$part->{counter_access}}) {
		my $name = $counter->{counter};
		print $OUTFILE "#define CFG_COUNTER_", $name, "\t", $counter_id, "\n";
		$counter_id++;
	}
	print $OUTFILE "#define CFG_NUM_COUNTERS\t", $counter_id, "\n";
	print $OUTFILE "\n";

	# iterate alarms
	my $alarm_id = 0;
	for my $alarm (@{$part->{alarm}}) {
		my $name = $alarm->{name};
		print $OUTFILE "#define CFG_ALARM_", $name, "\t", $alarm_id, "\n";
		$alarm_id++;
	}
	print $OUTFILE "#define CFG_NUM_ALARMS\t", $alarm_id, "\n";
	print $OUTFILE "\n";

	# iterate schedule tables
	my $schedtab_id = 0;
	for my $schedtab (@{$part->{sched_table}}) {
		my $name = $schedtab->{name};
		print $OUTFILE "#define CFG_SCHEDTAB_", $name, "\t", $schedtab_id, "\n";
		my $duration = $schedtab->{duration};
		print $OUTFILE "#define CFG_SCHEDTAB_", $name, "_DURATION\t", $duration, "\n";
		$schedtab_id++;
	}
	print $OUTFILE "#define CFG_NUM_SCHEDTABS\t", $schedtab_id, "\n";
	print $OUTFILE "\n";

	# iterate wait queues
	my $wq_id = 0;
	for my $wq (@{$part->{wait_queue}}) {
		my $name = $wq->{name};
		print $OUTFILE "#define CFG_WQ_", $name, "\t", $wq_id, "\n";
		$wq_id++;
	}
	print $OUTFILE "#define CFG_NUM_WQS\t", $wq_id, "\n";
	print $OUTFILE "\n";

	print $OUTFILE "\n";
	print $OUTFILE "#endif\n";

	close($OUTFILE) or die "Can't close $idh_file: $!";

	$part_id++;
}
