<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
/* scheduler_cfg.c -- AUTOGENERATED -- DO NOT EDIT -- */


#include <kernel.h>
#include <assert.h>
#include <sched_state.h>
#include <core_state.h>
#include <task_state.h>
#include <schedtab_state.h>
#include <alarm_state.h>
#include <task_defines.h>
#include <counter_defines.h>
#include <partition_defines.h>

/* forward declaration */
<#
	foreach (XPathNavigator nav in config.Select("/system/partition")) {
		string part_name = nav.GetAttribute("name", "");
#>
extern struct task task_dyn_part_<#= part_name #>[];
<#
	}
#>
<#
	int num_cpus = Convert.ToInt32(config.Select("/target")[0].GetAttribute("cpus", ""));
	int num_timeparts = Convert.ToInt32(config.Select("/system")[0].GetAttribute("timeparts", ""));
	int kern_contexts = 1;
	if (config.Select("/system")[0].GetAttribute("kern_contexts", "") != "")
	{
		kern_contexts = Convert.ToInt32(config.Select("/system")[0].GetAttribute("kern_contexts", ""));
	}
	int nmi_contexts = 1;
	if (config.Select("/system")[0].GetAttribute("nmi_contexts", "") != "")
	{
		nmi_contexts = Convert.ToInt32(config.Select("/system")[0].GetAttribute("nmi_contexts", ""));
	}
	int idle_contexts = 1;
	if (config.Select("/system")[0].GetAttribute("idle_contexts", "") != "")
	{
		idle_contexts = Convert.ToInt32(config.Select("/system")[0].GetAttribute("idle_contexts", ""));
	}
	int kern_stack_size = Convert.ToInt32(config.Select("/system")[0].GetAttribute("kern_stack_size", ""));
	int nmi_stack_size = Convert.ToInt32(config.Select("/system")[0].GetAttribute("nmi_stack_size", ""));
	int idle_stack_size = Convert.ToInt32(config.Select("/system")[0].GetAttribute("idle_stack_size", ""));

	Dictionary<int,string> sta_comment = new Dictionary<int,string>();
	Dictionary<int,string> sta_actions = new Dictionary<int,string>();
	Dictionary<int,int>    sta_arg1s = new Dictionary<int,int>();
	Dictionary<int,int>    sta_arg2s = new Dictionary<int,int>();
	Dictionary<int,string> sta_arg3s = new Dictionary<int,string>();
	Dictionary<int,int>    sta_arg4s = new Dictionary<int,int>();
	List<XPathNavigator> sched_tables = config.Select("/system/partition/sched_table");
	int num_schedtabs = sched_tables!=null ? sched_tables.Count : 0;

	for (int s = 0; s < num_schedtabs; s++) {
#>
extern struct alarm alarm_dyn_schedtab_<#=s#>;
<#
	}
#>

/* scheduler configuration */
const uint8_t num_cpus __section_cfg = <#= num_cpus #>;
const uint8_t num_timeparts __section_cfg = <#= num_timeparts #>;
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
struct sched_state sched_state_core_<#= cpu #> __section_sched_state_core(<#= cpu #>);
struct timepart_state timepart_states_core_<#= cpu #>[<#= num_cpus * num_timeparts #>] __section_bss_core(<#= cpu #>);
struct core_state core_state_core_<#= cpu #> __section_bss_core(<#= cpu #>);
<#
	}
#>

/* kernel stacks per CPU for ISRs and exceptions */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
unsigned char kern_stack_core_<#= cpu #>[<#= kern_stack_size #>] __aligned(ARCH_KERN_STACK_ALIGN) __section_kern_stack_core(<#= cpu #>);
unsigned char nmi_stack_core_<#= cpu #>[<#= nmi_stack_size #>] __aligned(ARCH_KERN_STACK_ALIGN) __section_nmi_stack_core(<#= cpu #>);
unsigned char idle_stack_core_<#= cpu #>[<#= idle_stack_size #>] __aligned(ARCH_KERN_STACK_ALIGN) __section_stack_core(<#= cpu #>);
<#
	}
#>

/** per-CPU kernel register contexts */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
struct arch_ctxt_frame kern_ctxts_core_<#= cpu #>[<#= kern_contexts #>] __section_context_core(<#= cpu #>);
struct arch_ctxt_frame nmi_ctxts_core_<#= cpu #>[<#= nmi_contexts #>] __section_context_core(<#= cpu #>);
struct arch_ctxt_frame idle_ctxts_core_<#= cpu #>[<#= idle_contexts #>] __section_context_core(<#= cpu #>);
<#
	}
#>

/** per-CPU configuration */
const struct core_cfg core_cfg[<#= num_cpus #>] = {
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
	/* CPU <#= cpu #> */ {
		.sched = &sched_state_core_<#= cpu #>,
		.timeparts = timepart_states_core_<#= cpu #>,
		.core_state = &core_state_core_<#= cpu #>,

		.kern_stack = kern_stack_core_<#= cpu #>,
		.nmi_stack =  nmi_stack_core_<#= cpu #>,
		.idle_stack = idle_stack_core_<#= cpu #>,
		.kern_ctxts = kern_ctxts_core_<#= cpu #>,
		.nmi_ctxts =  nmi_ctxts_core_<#= cpu #>,
		.idle_ctxts = idle_ctxts_core_<#= cpu #>,
	},
<#
	}
#>
};

const size_t kern_stack_size = <#= kern_stack_size #>;
const size_t nmi_stack_size = <#= nmi_stack_size #>;
const size_t idle_stack_size = <#= idle_stack_size #>;
const uint8_t kern_num_ctxts = <#= kern_contexts #>;
const uint8_t nmi_num_ctxts = <#= nmi_contexts #>;
const uint8_t idle_num_ctxts = <#= idle_contexts #>;

/* sched_table table */
const uint8_t num_schedtabs __section_cfg = <#=num_schedtabs#>;
const struct schedtab_cfg schedtab_cfg[<#=num_schedtabs#>] = {
<#
	int sched_table_id = 0;
	int sta_id = 0;
	int last_o = 0;
	foreach (XPathNavigator partition in config.Select("/system/partition"))
	{

		foreach (XPathNavigator sched_table in partition.Select("sched_table"))
		{
			string sched_flags = sched_table.GetAttribute("repeating", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase) ? " | SCHEDTAB_FLAG_REPEATING" : "";

			string sync_attr = sched_table.GetAttribute("sync", "");
			if (String.IsNullOrEmpty(sync_attr) || sync_attr.Equals("none", System.StringComparison.OrdinalIgnoreCase))
			{
				/* no action */
			}
			else if (sync_attr.Equals("explicit", System.StringComparison.OrdinalIgnoreCase))
			{
				sched_flags += " | SCHEDTAB_FLAG_SYNC_EXPLICIT";
			}
			else if (sync_attr.Equals("implicit", System.StringComparison.OrdinalIgnoreCase))
			{
				sched_flags += " | SCHEDTAB_FLAG_SYNC_IMPLICIT";
			}
			else
			{
				/* FIXME: raise error! */
			}

			int complete_duration =  Convert.ToInt32(sched_table.GetAttribute("duration", ""));
			int precision = 0;
			if (!String.IsNullOrEmpty(sched_table.GetAttribute("precision", "")))
			{
				precision = Convert.ToInt32(sched_table.GetAttribute("precision", ""));
			}
#>
	/* partition '<#=partition.GetAttribute("name", "")#>' sched_table <#=sched_table_id#> '<#=sched_table.GetAttribute("name", "")#>' */ {
		.counter_id = OS_COUNTER_<#=sched_table.GetAttribute("counter", "")#>, /* <#=sched_table.GetAttribute("counter", "")#> */
		.flags = 0<#=sched_flags#>,
		.duration = <#=complete_duration#>,
		.precision = <#=precision#>,
		.alarm = &alarm_dyn_schedtab_<#=sched_table_id#>,
		.start_idx = <#=sta_id#>,
	},
<#
			sched_table_id++;
			int first_expiry_id = sta_id;
			last_o = 0;
			int duration = 0;

			// Emit initial START indicator
			sta_comment.Add(sta_id,"schedule table '"+sched_table.GetAttribute("name", "")+"'");
			sta_actions.Add(sta_id, "SCHEDTAB_ACTION_START");
			sta_id++;

			foreach (XPathNavigator expiry in sched_table.Select("expiry"))
			{
				int oo = 0;
				String offset = expiry.GetAttribute("offset", "");
				if(!String.IsNullOrEmpty(offset))
				{
					sta_comment.Add(sta_id,"offset "+offset);
				}
				else
				{
					sta_comment.Add(sta_id,"no offset ");
				}

				//Emit SHORTEN / LENGTHEN before the wait sequence
				string shorten = expiry.GetAttribute("max_shorten", "");
				if(!String.IsNullOrEmpty(shorten))
				{
					int max_shorten = Convert.ToInt32(shorten);
					if(max_shorten>0)
					{
						sta_actions.Add(sta_id, "SCHEDTAB_ACTION_SHORTEN");
						sta_arg4s.Add(sta_id, max_shorten);
						sta_id++;
					}
				}

				string lengthen = expiry.GetAttribute("max_lengthen", "");
				if(!String.IsNullOrEmpty(lengthen))
				{
					int max_lengthen = Convert.ToInt32(lengthen);
					if(max_lengthen>0)
					{
						sta_actions.Add(sta_id, "SCHEDTAB_ACTION_LENGTHEN");
						sta_arg4s.Add(sta_id, max_lengthen);
						sta_id++;
					}
				}

				//Emit a WAIT sequence to synchronize to offset
				if(!String.IsNullOrEmpty(offset))
				{
					oo = Convert.ToInt32(offset) - last_o;

					if(oo>0)
					{
						sta_actions.Add(sta_id, "SCHEDTAB_ACTION_WAIT");
						sta_arg4s.Add(sta_id, oo);
						sta_id++;
					}
				}

				//generate in order: tasks, hooks, events (required by SWS_Os_00412)
				foreach(XPathNavigator action_task in expiry.Select("action_task"))
				{
					String part_name = action_task.GetAttribute("partition", "");
					String task_name = action_task.GetAttribute("task","");

					sta_actions.Add(sta_id, "SCHEDTAB_ACTION_TASK");
					//if(task_map.ContainsKey(action_task.GetAttribute("task","")))
					{
						sta_arg3s.Add(sta_id, "&task_dyn_part_"+part_name+"[OS_TASK_LOCAL_ID_"+part_name+"_"+task_name+"]");
					}
					sta_id++;
				}
				foreach(XPathNavigator action_hook in expiry.Select("action_hook"))
				{
					String part_name = action_hook.GetAttribute("partition", "");
					String hook_name = action_hook.GetAttribute("hook","");

					sta_actions.Add(sta_id, "SCHEDTAB_ACTION_HOOK");
					//if(task_map.ContainsKey(action_hook.GetAttribute("hook","")))
					{
						sta_arg3s.Add(sta_id, "&task_dyn_part_"+part_name+"[OS_TASK_LOCAL_ID_"+part_name+"_"+hook_name+"]");
					}
					sta_id++;
				}
				foreach(XPathNavigator action_event in expiry.Select("action_event"))
				{
					String part_name = action_event.GetAttribute("partition", "");
					String task_name = action_event.GetAttribute("task","");

					sta_actions.Add(sta_id, "SCHEDTAB_ACTION_EVENT");
					//if(task_map.ContainsKey(action_event.GetAttribute("task","")))
					{
						sta_arg3s.Add(sta_id, "&task_dyn_part_"+part_name+"[OS_TASK_LOCAL_ID_"+part_name+"_"+task_name+"]");
					}
					sta_arg1s.Add(sta_id, Convert.ToInt32(action_event.GetAttribute("bit", "")));
					sta_id++;
				}

				last_o = Convert.ToInt32(offset);

			}
			duration =  Convert.ToInt32(sched_table.GetAttribute("duration", "")) - last_o;

			// Emit final WAIT + WRAP sequence
			sta_comment.Add(sta_id,"offset "+Convert.ToInt32(sched_table.GetAttribute("duration", "")));
			if(duration>0)
			{
				sta_actions.Add(sta_id, "SCHEDTAB_ACTION_WAIT");
				sta_arg4s.Add(sta_id, duration);
				sta_id++;
			}
			if(sta_comment.ContainsKey(sta_id))
			{
				sta_comment[sta_id] += ", wrap around to  "+first_expiry_id;
			}
			else
			{
				sta_comment.Add(sta_id,"wrap around to  "+first_expiry_id);
			}
			sta_actions.Add(sta_id, "SCHEDTAB_ACTION_WRAP");
			sta_arg2s.Add(sta_id, first_expiry_id);
			sta_id++;

		}
	}
#>
};
<#
	foreach (XPathNavigator part in config.Select("/system/partition")) {
		String part_name = part.GetAttribute("name", "");
		int cpu = 0;
		if (part.GetAttribute("cpu", "") != "") {
			cpu = Convert.ToInt32(part.GetAttribute("cpu", ""));
		}
		int part_schedtabs = part.Select("./sched_table").Count;

		{
#>
#ifdef CODEWARRIOR
struct schedtab schedtab_dyn_part_<#= part_name #>[<#= Math.Max(part_schedtabs, 1) #>] __section_bss_core(<#= cpu #>);
#else
struct schedtab schedtab_dyn_part_<#= part_name #>[<#= part_schedtabs #>] __section_bss_core(<#= cpu #>);
#endif
<#
		}
	}
#>

/* schedtab_action table */
const struct schedtab_action_cfg schedtab_action_cfg[<#=sta_id#>] = {
<#
	for(int i=0; i<sta_id; i++)
	{
		string comment = "#" + i;
		if(sta_comment.ContainsKey(i))
		{
			comment += ":  " + sta_comment[i];
		}
#>
	{ /* <#=comment#> */
		.action = <#=sta_actions[i]#>,
<#
		if (sta_arg1s.ContainsKey(i)) {
#>
		.event_bit = <#=sta_arg1s[i]#>,
<#
		}
		if (sta_arg2s.ContainsKey(i)) {
#>
		.next_idx = <#=sta_arg2s[i]#>,
<#
		}
		if (sta_arg3s.ContainsKey(i)) {
#>
		.u.task = <#=sta_arg3s[i]#>,
<#
		}
		if (sta_arg4s.ContainsKey(i)) {
#>
		.u.time = <#=sta_arg4s[i]#>,
<#
		}
#>
	},
<#
	}
#>

};
