<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
/* task_cfg.c -- AUTOGENERATED -- DO NOT EDIT -- */
<#
	int num_cpus = Convert.ToInt32(config.Select("/target")[0].GetAttribute("cpus", ""));
	int num_tasks = config.Select("/system/partition/task").Count +
	                config.Select("/system/partition/isr").Count +
	                config.Select("/system/partition/hook").Count +
	                config.Select("/system/partition/invokable").Count;
	int idle_contexts = 1;
	if (config.Select("/system")[0].GetAttribute("idle_contexts", "") != "")
	{
		idle_contexts = Convert.ToInt32(config.Select("/system")[0].GetAttribute("idle_contexts", ""));
	}

	var core_reg_frames = new int[num_cpus];
	var core_fpu_frames = new int[num_cpus];
	var core_ctxt_frames = new int[num_cpus];
#>

#include <kernel.h>
#include <assert.h>
#include <task_state.h>
#include <part_state.h>
#include <rpc_state.h>
#include <address_defines.h>
#include <task_defines.h>
#include <partition_defines.h>
#include <arch_mpu_state.h>
#include <sched_state.h>

/* forward declaration */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
extern struct arch_reg_frame kernel_reg_frames_core_<#= cpu #>[];
extern struct arch_fpu_frame kernel_fpu_frames_core_<#= cpu #>[];
extern struct arch_ctxt_frame kernel_ctxt_frames_core_<#= cpu #>[];
extern struct timepart_state timepart_states_core_<#= cpu #>[];
<#
	}
#>
extern const struct arch_mpu_task_cfg mpu_task_cfg[];
extern const struct part_cfg part_cfg[];


/* task dynamic data (one dedicated array per partition) */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
struct task task_dyn_idle_<#= cpu #>[1] __section_bss_core(<#= cpu #>);
<#
	}

	foreach (XPathNavigator part in config.Select("/system/partition")) {
		string part_name = part.GetAttribute("name", "");
		int cpu = 0;
		if (part.GetAttribute("cpu", "") != "") {
			cpu = Convert.ToInt32(part.GetAttribute("cpu", ""));
		}
		int tasks = part.Select("./task").Count + part.Select("./isr").Count + part.Select("./hook").Count + part.Select("./invokable").Count;
		int invokables = part.Select("./invokable").Count;
#>
struct task task_dyn_part_<#= part_name #>[<#= tasks #>] __section_bss_core(<#= cpu #>);
struct rpc rpc_dyn_part_<#= part_name #>[<#= invokables #>] __section_bss_core(<#= cpu #>);
<#
	}
#>

/* task configuration */
const uint16_t num_tasks __section_cfg = <#= num_cpus + num_tasks #>;
const struct task_cfg task_cfg[<#= num_cpus + num_tasks #>] = {
<#
	int overall_task_id = 0;
	// don't assign contexts used by (idle-) partitions twice

	/* generate idle tasks in idle partitions (one for each core) */
	for (int cpu = 0; cpu < num_cpus; cpu++) {
#>
	/* #<#=overall_task_id++#>: idle task on CPU <#= cpu #> */ {
		.task = &task_dyn_idle_<#=cpu#>[0],
		.name = "*IDLE*",
		.task_id = 0,
		.cpu_id = <#=cpu#>,
		.part_cfg = &part_cfg[<#= cpu #>],
		.timepart = &timepart_states_core_<#= cpu #>[0],

		.base_prio = 0,
		.elev_prio = 0, /* not used */
		.regs = &kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]++#>],
		.fpu = NULL, /* not used */

		.ctxt = &kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu] #>],
		.num_ctxts = <#= idle_contexts #>,
<#
		core_ctxt_frames[cpu] += idle_contexts;
#>

		.mpu_task_cfg = &mpu_task_cfg[<#= cpu #>],

		.irq = 0, /* not used */
		.max_activations = 1, /* not used */

		.cfgflags_type = TASK_TYPE_HOOK,
	},
<#
	}

	foreach (XPathNavigator part in config.Select("/system/partition"))
	{
		string part_name = part.GetAttribute("name", "");
		string part_id = "OS_PARTITION_ID_" + part_name;
		int task_id = 0;
		int invokable_id = 0;

		string error_hook_name = part.GetAttribute("error_hook", "");
		int num_error_states = 0;
		if (error_hook_name != "") {
			num_error_states = Convert.ToInt32(part.GetAttribute("error_records", ""));
		}

		int cpu = 0;
		if (part.GetAttribute("cpu", "") != "") {
			cpu = Convert.ToInt32(part.GetAttribute("cpu", ""));
		}
		int timepart = 0;
		if (part.GetAttribute("timepart", "") != "") {
			timepart = Convert.ToInt32(part.GetAttribute("timepart", ""));
		}

		foreach (XPathNavigator task in part.Select("./task"))
		{
			string task_name = task.GetAttribute("name", "");
			string activation_comment = "";
			int max_activations = 1;
			string elev_prio = "";
			string flag_activatable = "";
			string flag_blocking = "";
			string flag_elev = "";

			/* ARINC default attributes */
			string period = "-1";
			string capacity = "-1";

			XPathNavigator invoke = task.SelectSingleNode("invoke");
			if (invoke != null && invoke.GetAttribute("entry","") != "") {
				flag_activatable = " | TASK_CFGFLAG_ACTIVATABLE";
			}

			string stack_size = "0";
			if (invoke != null && invoke.GetAttribute("stack_size","") != "") {
				stack_size = invoke.GetAttribute("stack_size", "");
			}

			if(task.GetAttribute("eprio", "")!="")
			{
				elev_prio = "" + task.GetAttribute("eprio", "") + ", /* elevated prio */";
				flag_elev = " | TASK_CFGFLAG_ELEV_PRIO";
			}
			else
			{
				elev_prio = "" + task.GetAttribute("prio", "") + ",";
			}

			if(task.GetAttribute("blocking", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
			{
				activation_comment = " /* not used */\n";
				flag_blocking = " | TASK_CFGFLAG_MAYBLOCK";
			}
			else
			{
				if(task.GetAttribute("activations","")!="")
				{
					max_activations = Convert.ToInt32(task.GetAttribute("activations",""));
				}
			}

			if (task.GetAttribute("period", "") != "")
			{
				period = task.GetAttribute("period", "");
			}
			if (task.GetAttribute("capacity", "") != "")
			{
				capacity = task.GetAttribute("capacity", "");
			}

			int contexts = 1;
			if (task.GetAttribute("contexts", "") != "")
			{
				contexts = Convert.ToInt32(task.GetAttribute("contexts", ""));
			}
#>
	/* #<#=overall_task_id++#>: <#=flag_blocking!=""?"blocking ":""#>task '<#=task_name#>' in partition '<#=part_name#>' */ {
		.task = &task_dyn_part_<#= part_name #>[<#=task_id#>],
		.name = "<#=task_name#>",
		.task_id = <#=task_id++#>,
		.cpu_id = <#=cpu#>,
		.part_cfg = &part_cfg[<#=part_id#>],
		.timepart = &timepart_states_core_<#= cpu #>[<#= timepart #>],

		.base_prio = <#=task.GetAttribute("prio", "")#>,
		.elev_prio = <#=elev_prio#>
		.regs = &kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]++#>],
<#
		if(task.GetAttribute("fpu", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
		{
#>
		.fpu = &kernel_fpu_frames_core_<#= cpu #>[<#=core_fpu_frames[cpu]++#>],
<#
		}
		else
		{
#>
		.fpu = NULL, /* not used */
<#
		}
#>
		.ctxt = &kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu] #>],
		.num_ctxts = <#= contexts #>,
<#
		core_ctxt_frames[cpu] += contexts;
#>

		.mpu_task_cfg = &mpu_task_cfg[<#= overall_task_id-1 #>],

		.irq = 0, /* not used */
		.max_activations = <#=max_activations#>,<#=activation_comment#>

		.period = <#=period#>,
		.capacity = <#=capacity#>,

		.entry = OS_TASK_<#=part_name#>_<#=task_name#>_ENTRY,
		.stack = OS_TASK_<#=part_name#>_<#=task_name#>_STACK,
		.stack_size = <#=stack_size#>,
		.arg0  = OS_TASK_<#=part_name#>_<#=task_name#>_ARG0,

		.cfgflags_type = TASK_TYPE_TASK<#=flag_activatable#><#=flag_blocking#><#=flag_elev#>,
	},
<#
		}
		foreach (XPathNavigator isr in part.Select("./isr"))
		{
			string task_name = isr.GetAttribute("name", "");
			string flag_activatable = "";
			string flag_blocking = "";
			string flag_unmask = "";

			XPathNavigator invoke = isr.SelectSingleNode("invoke");
			if (invoke != null && invoke.GetAttribute("entry","") != "") {
				flag_activatable = " | TASK_CFGFLAG_ACTIVATABLE";
			}

			string stack_size = "0";
			if (invoke != null && invoke.GetAttribute("stack_size","") != "") {
				stack_size = invoke.GetAttribute("stack_size", "");
			}

			if(isr.GetAttribute("blocking", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
			{
				flag_blocking = " | TASK_CFGFLAG_MAYBLOCK";
			}

			if(isr.GetAttribute("unmask", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
			{
				flag_unmask = " | TASK_CFGFLAG_ISR_UNMASK";
			}

			int contexts = 1;
			if (isr.GetAttribute("contexts", "") != "")
			{
				contexts = Convert.ToInt32(isr.GetAttribute("contexts", ""));
			}
#>
	/* #<#=overall_task_id++#>: <#=flag_blocking!=""?"blocking ":""#>ISR '<#=task_name#>' in partition '<#=part_name#>' */ {
		.task = &task_dyn_part_<#= part_name #>[<#=task_id#>],
		.name = "<#=task_name#>",
		.task_id = <#=task_id++#>,
		.cpu_id = <#=cpu#>,
		.part_cfg = &part_cfg[<#=part_id#>],
		.timepart = &timepart_states_core_<#= cpu #>[<#= timepart #>],

		.base_prio = <#=isr.GetAttribute("prio", "")#>,
		.elev_prio = <#=isr.GetAttribute("prio", "")#>, /* not used */
		.regs = &kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]++#>],
<#
		if(isr.GetAttribute("fpu", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
		{
#>
		.fpu = &kernel_fpu_frames_core_<#= cpu #>[<#=core_fpu_frames[cpu]++#>],
<#
		}
		else
		{
#>
		.fpu = NULL, /* not used */
<#
		}
#>
		.ctxt = &kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu] #>],
		.num_ctxts = <#= contexts #>,
<#
		core_ctxt_frames[cpu] += contexts;
#>

		.mpu_task_cfg = &mpu_task_cfg[<#= overall_task_id-1 #>],

		.irq = <#=isr.GetAttribute("vector", "")#>,
		.max_activations = 1, /* not used */

		.entry = OS_TASK_<#=part_name#>_<#=task_name#>_ENTRY,
		.stack = OS_TASK_<#=part_name#>_<#=task_name#>_STACK,
		.stack_size = <#=stack_size#>,
		.arg0  = OS_TASK_<#=part_name#>_<#=task_name#>_ARG0,

		.cfgflags_type = TASK_TYPE_ISR<#=flag_activatable#><#=flag_blocking#><#=flag_unmask#>,
	},
<#
		}


		foreach (XPathNavigator hook in part.Select("./hook"))
		{
			string task_name = hook.GetAttribute("name", "");
			string activation_comment = "/* not used */";
			int max_activations = 1;
			string flag_activatable = "";
			string flag_blocking = "";

			XPathNavigator invoke = hook.SelectSingleNode("invoke");
			if (invoke != null && invoke.GetAttribute("entry","") != "") {
				flag_activatable = " | TASK_CFGFLAG_ACTIVATABLE";
			}

			string stack_size = "0";
			if (invoke != null && invoke.GetAttribute("stack_size","") != "") {
				stack_size = invoke.GetAttribute("stack_size", "");
			}

			if(hook.GetAttribute("blocking", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
			{
				flag_blocking = " | TASK_CFGFLAG_MAYBLOCK";
			}

			int contexts = 1;
			if (hook.GetAttribute("contexts", "") != "")
			{
				contexts = Convert.ToInt32(hook.GetAttribute("contexts", ""));
			}

			if (task_name == error_hook_name) {
				max_activations = num_error_states;
				activation_comment = "/* error hook */";
			}

#>
	/* #<#=overall_task_id++#>: <#=flag_blocking!=""?"blocking ":""#>hook '<#=task_name#>' in partition '<#=part_name#>' */ {
		.task = &task_dyn_part_<#= part_name #>[<#=task_id#>],
		.name = "<#=task_name#>",
		.task_id = <#=task_id++#>,
		.cpu_id = <#=cpu#>,
		.part_cfg = &part_cfg[<#=part_id#>],
		.timepart = &timepart_states_core_<#= cpu #>[<#= timepart #>],

		.base_prio = <#=hook.GetAttribute("prio", "")#>,
		.elev_prio = <#=hook.GetAttribute("prio", "")#>, /* not used */
		.regs = &kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]++#>],
<#
		if(hook.GetAttribute("fpu", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
		{
#>
		.fpu = &kernel_fpu_frames_core_<#= cpu #>[<#=core_fpu_frames[cpu]++#>],
<#
		}
		else
		{
#>
		.fpu = NULL, /* not used */
<#
		}
#>
		.ctxt = &kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu] #>],
		.num_ctxts = <#= contexts #>,
<#
		core_ctxt_frames[cpu] += contexts;
#>

		.mpu_task_cfg = &mpu_task_cfg[<#= overall_task_id-1 #>],

		.irq = 0, /* not used */
		.max_activations = <#=max_activations#>,<#=activation_comment#>

		.entry = OS_TASK_<#=part_name#>_<#=task_name#>_ENTRY,
		.stack = OS_TASK_<#=part_name#>_<#=task_name#>_STACK,
		.stack_size = <#=stack_size#>,
		.arg0  = OS_TASK_<#=part_name#>_<#=task_name#>_ARG0,

		.cfgflags_type = TASK_TYPE_HOOK<#=flag_activatable#><#=flag_blocking#>,
	},
<#
		}


		foreach (XPathNavigator invokable in part.Select("./invokable"))
		{
			string task_name = invokable.GetAttribute("name", "");
			string flag_activatable = "";
			string flag_blocking = "";

			XPathNavigator invoke = invokable.SelectSingleNode("invoke");
			if (invoke != null && invoke.GetAttribute("entry","") != "") {
				flag_activatable = " | TASK_CFGFLAG_ACTIVATABLE";
			}

			string stack_size = "0";
			if (invoke != null && invoke.GetAttribute("stack_size","") != "") {
				stack_size = invoke.GetAttribute("stack_size", "");
			}

			if(invokable.GetAttribute("blocking", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
			{
				flag_blocking = " | TASK_CFGFLAG_MAYBLOCK";
			}

			int contexts = 1;
			if (invokable.GetAttribute("contexts", "") != "")
			{
				contexts = Convert.ToInt32(invokable.GetAttribute("contexts", ""));
			}

#>
	/* #<#=overall_task_id++#>: <#=flag_blocking!=""?"blocking ":""#>invokable '<#=task_name#>' in partition '<#=part_name#>' */ {
		.task = &task_dyn_part_<#= part_name #>[<#=task_id#>],
		.name = "<#=task_name#>",
		.task_id = <#=task_id++#>,
		.cpu_id = <#=cpu#>,
		.part_cfg = &part_cfg[<#=part_id#>],
		.timepart = &timepart_states_core_<#= cpu #>[<#= timepart #>],

		.base_prio = <#=invokable.GetAttribute("prio", "")#>,
		.elev_prio = <#=invokable.GetAttribute("prio", "")#>, /* not used */
		.regs = &kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]++#>],
<#
		if(invokable.GetAttribute("fpu", "").Equals("yes",System.StringComparison.OrdinalIgnoreCase))
		{
#>
		.fpu = &kernel_fpu_frames_core_<#= cpu #>[<#=core_fpu_frames[cpu]++#>],
<#
		}
		else
		{
#>
		.fpu = NULL, /* not used */
<#
		}
#>
		.ctxt = &kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu] #>],
		.num_ctxts = <#= contexts #>,
<#
		core_ctxt_frames[cpu] += contexts;
#>

		.mpu_task_cfg = &mpu_task_cfg[<#= overall_task_id-1 #>],

		.irq = 0, /* not used */
		.max_activations = 1, /* not used */
		.rpc = &rpc_dyn_part_<#= part_name #>[<#= invokable_id++ #>],

		.entry = OS_TASK_<#=part_name#>_<#=task_name#>_ENTRY,
		.stack = OS_TASK_<#=part_name#>_<#=task_name#>_STACK,
		.stack_size = <#=stack_size#>,
		.arg0  = OS_TASK_<#=part_name#>_<#=task_name#>_ARG0,

		.cfgflags_type = TASK_TYPE_INVOKABLE<#=flag_activatable#><#=flag_blocking#>,
	},
<#
		}




	}
#>
};

/* registers contexts (one for each partition + shared regs for tasks) */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
		{
#>
#ifdef CODEWARRIOR
struct arch_reg_frame kernel_reg_frames_core_<#= cpu #>[<#=Math.Max(core_reg_frames[cpu], 1)#>] __section_reg_core(<#= cpu #>);
#else
struct arch_reg_frame kernel_reg_frames_core_<#= cpu #>[<#=core_reg_frames[cpu]#>] __section_reg_core(<#= cpu #>);
#endif
<#
		}
	}
#>

/* FPU contexts (tasks can disable or share FPU registers) */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
		{
#>
#ifdef CODEWARRIOR
struct arch_fpu_frame kernel_fpu_frames_core_<#= cpu #>[<#=Math.Max(core_fpu_frames[cpu], 1)#>] __section_reg_core(<#= cpu #>);
#else
struct arch_fpu_frame kernel_fpu_frames_core_<#= cpu #>[<#=core_fpu_frames[cpu]#>] __section_reg_core(<#= cpu #>);
#endif
<#
		}
	}
#>

/* Hardware registers contexts (variable per task) */
<#
	for (int cpu = 0; cpu < num_cpus; cpu++) {
		{
#>
#ifdef CODEWARRIOR
struct arch_ctxt_frame kernel_ctxt_frames_core_<#= cpu #>[<#=Math.Max(core_ctxt_frames[cpu], 1)#>] __section_context_core(<#= cpu #>);
#else
struct arch_ctxt_frame kernel_ctxt_frames_core_<#= cpu #>[<#=core_ctxt_frames[cpu]#>] __section_context_core(<#= cpu #>);
#endif
<#
		}
	}
#>
