<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
/* mpu_cfg.c -- AUTOGENERATED -- DO NOT EDIT -- */
<#
	int num_cpus = Convert.ToInt32(config.Select("/target")[0].GetAttribute("cpus", ""));
	int num_parts = config.Select("/system/partition").Count;
	int num_tasks = config.Select("/system/partition/task").Count +
	                config.Select("/system/partition/isr").Count +
	                config.Select("/system/partition/hook").Count +
	                config.Select("/system/partition/invokable").Count;
	int cpu;
    string target_name = config.Select("/target")[0].GetAttribute("name", "");


	/* check if final_memory.xml exists */
	bool final_run = false;
	string mpu_arch = "";
	if (config.Select("/memory_layout/part").Count != 0) {
		mpu_arch = config.Select("/memory_layout")[0].GetAttribute("mpu_arch", "");
		final_run = true;
	} else {
		mpu_arch = config.Select("/target")[0].GetAttribute("mpu_arch", "");
	}

	bool split_code_data = false;
	bool gen_pagetables = false;
	string region1_name = "region";
	string region2_name = "";
	if (mpu_arch.Contains("tricore_tc161")) {
		split_code_data = true;
		region1_name = "data";
		region2_name = "code";
	}
	if (mpu_arch.Contains("arm_cortexa")) {
		gen_pagetables = true;
	}
#>
/*
 * Settings:
 * Target name: <#= target_name #>
 * MPU arch:    <#= mpu_arch #>
 * CPUs:        <#= num_cpus #>
 * Partitions:  <#= num_parts #>
 * Total tasks: <#= num_tasks #>
 * Page tables: <#= gen_pagetables #>
 */

#include <arch_mpu_state.h>
#include <hv_compiler.h>

<#
	if (gen_pagetables) {
		/* MMU version -- generate page tables */
		uint num_pt2_tables = 0;

		// ARM uses two-level page tables with a 16K aligned first-level directory
		// and 1K aligned second level directories

		// iterate all partitions
		int part_id = 0;
		foreach (XPathNavigator nav in config.Select("/system/partition")) {
			string part_name = nav.GetAttribute("name", "");
			List<uint> pfs = new List<uint>();
			List<W> ws = new List<W>();

			// go thru <part> list ins memory.xml and fetch all matching windows
			// locate according partition in memory.xml
			foreach (XPathNavigator nav2 in config.Select("/memory_layout/part[@name=\"__KERNEL__\"]/mpu_window")) {
				// dump all windows
				W w = new W();
				string text;

				text = nav2.GetAttribute("start", "");
				w.start = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				text = nav2.GetAttribute("size", "");
				w.size = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				w.user = false;
				w.read = Convert.ToInt32(nav2.GetAttribute("read", "")) != 0;
				w.write = Convert.ToInt32(nav2.GetAttribute("write", "")) != 0;
				w.exec = Convert.ToInt32(nav2.GetAttribute("exec", "")) != 0;
				w.cached = Convert.ToInt32(nav2.GetAttribute("cached", "")) != 0;

				text = nav2.GetAttribute("arch", "");
				w.arch = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				// NOTE: sometimes, SHMs are not properly aligned ...
				if ((w.start & 0xfff) != 0 || (w.size & 0xfff) != 0) {
					//FIXME
					//die "partition '", $part->{name}, "' window id '", $window->{id}, "' has unaligned start/size\n";
				}

				ws.Add(w);
			}
			foreach (XPathNavigator nav2 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/mpu_window")) {
				// dump all windows
				W w = new W();
				string text;

				text = nav2.GetAttribute("start", "");
				w.start = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				text = nav2.GetAttribute("size", "");
				w.size = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				w.user = true;
				w.read = Convert.ToInt32(nav2.GetAttribute("read", "")) != 0;
				w.write = Convert.ToInt32(nav2.GetAttribute("write", "")) != 0;
				w.exec = Convert.ToInt32(nav2.GetAttribute("exec", "")) != 0;
				w.cached = Convert.ToInt32(nav2.GetAttribute("cached", "")) != 0;

				text = nav2.GetAttribute("arch", "");
				w.arch = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);

				// NOTE: sometimes, SHMs are not properly aligned ...
				if ((w.start & 0xfff) != 0 || (w.size & 0xfff) != 0) {
					//FIXME
					//die "partition '", $part->{name}, "' window id '", $window->{id}, "' has unaligned start/size\n";
				}

				ws.Add(w);
			}

			// sort by start address, ascending
			ws.Sort(W.CompareByStart);

			// the following algorithm scans linearly thru the address space
			// and creates page tables for all windows it finds.
			// it does this in two passes: the first pass generates all 2nd level
			// page tables, then generates the first level page table.
			// the page tables are kept in <pts> and are referenced by their address
			uint addr = 0;
			int pos = 0;
			int level = 1;
			foreach (var w in ws) {
again:
				// ARM page table bits
				//
				// PTE_XN		0x001	execute never
				// PTE_P		0x002	present, type: 4K page
				// PTE_B		0x004	buffered
				// PTE_C		0x008	cached
				// PTE_AP0		0x010	AP0
				// PTE_AP1		0x020	AP1
				// PTE_TEX0		0x040	TEX0
				// PTE_TEX1		0x080	TEX1
				// PTE_TEX2		0x100	TEX2
				// PTE_AP2		0x200	AP2
				// PTE_S		0x400	shareable
				// PTE_NG		0x800	non global
				uint bits = 0x002;	// PTE_P

				// Memory protection (user+rwx)
				//
				// AP 2..0 values
				//    kernel   user usage
				// 000  --      --
				// 001  rw      --  kernel RW
				// 010  rw      ro
				// 011  rw      rw  user RW
				// 100  ??      ??
				// 101  ro      --  kernel R-
				// 110  ro      --
				// 111  ro      ro  user R-
				bits |= 0x010;	// PTE_AP0
				if (w.user) {
					bits |= 0x020;	// PTE_AP1
				}
				if (!w.write) {
					bits |= 0x200;	// PTE_AP2
				}
				if (!w.exec) {
					bits |= 0x001;	// PTE_XN
				}

				// Cache mode
				//
				// TEX C B  memory type           shareable
				// 000 0 0  UC, strongly ordered  shareable
				// 000 0 1  UC, device            shareable
				// 000 1 0  WT, normal            S
				// 000 1 1  WB, normal            S
				// 001 0 0  UC, normal            S
				// 001 1 1  WBWA, normal          S
				// 010 0 0  non-shared device     not shareable

				string cachemode = "";
				if (w.cached) {
					if (mpu_arch.Contains("arm_cortexa")) {
						// Cortex-A8 is always a single core and does not support WBWA
						cachemode = "WB unshared";
						bits |= 0x008|0x004;	// PTE_C | PTE_B
					} else {
						// Assume: all others are SMP cores
						cachemode = "WBWA shareable";
						bits |= 0x040|0x008|0x004|0x400;	// PTE_TEX0 | PTE_C | PTE_B | PTE_S
					}
				} else {
					cachemode = "UC strongly ordered";
				}

				if (level > 1) {
					// fill up currently open page table with invalid entries
					while (addr < w.start && pos < 256) {
#>
	/* <#= String.Format("0x{0:X8}", addr) #> */	0,
<#

						addr += 0x1000;	// 4K
						pos++;
					}
					if (pos == 256) {
#>
};
<#
						level = 1;
					}
				}
				if (level == 1) {
					while (addr < (w.start & 0xfff00000)) {
						addr += 0x100000;	// 1M
					}
				}
				if (level == 1 && (addr & 0xfffff) == 0) {
					// open new page table
#>
const uint32_t _pt2_part<#= part_id #>_<#= String.Format("0x{0:X8}", addr) #>[256] __section_cfg_pt2 __aligned(1024) = {
<#
					pfs.Add(addr);
					pos = 0;
					level = 2;
					num_pt2_tables++;
				}

				// fill with meaning-ful entries
				if (addr < w.start) {
					goto again;
				}

				while (addr < (w.start + w.size) && pos < 256) {
#>
	/* <#= String.Format("0x{0:X8}", addr) #> */	<#= String.Format("0x{0:X8}", addr) #> | <#= String.Format("0x{0:X3}", bits) #>, /* <#= w.user?"u":"-" #><#= w.read?"r":"-" #><#= w.write?"w":"-" #><#= w.exec?"x":"-" #> <#= cachemode #> */
<#
					addr += 0x1000;	// 4K
					pos++;
				}
				if (pos == 256) {
					goto again;
				}
			}
			// close last open page table
			if (level > 1) {
#>
};
<#
			}

			// now emit 1st level page table
			addr = 0;
#>
const uint32_t _pt1_part<#= part_id #>[4096] __section_cfg_pt1 __aligned(16384) = {
<#
			foreach (var start in pfs) {
				while (addr < start) {
#>
	/* <#= String.Format("0x{0:X8}", addr) #> */	0,
<#
					addr += 0x100000;	// 1M
				}
				// NOTE: cannot use "|" in relocs, must use "+" to concat address and page table bits!
#>
	/* <#= String.Format("0x{0:X8}", addr) #> */	(uint32_t)_pt2_part<#= part_id #>_<#= String.Format("0x{0:X8}", addr) #> + 0x1,
<#
				addr += 0x100000;	// 1M
			}
#>
};
<#
			part_id++;
		}

		// generate dummy level 2 tables for proper alignment
		// FIXME: num_parts * 8 is a rough metric to get the number of page tables,
		// FIXME: but better add a config element to configure this number!
		while (num_pt2_tables < num_parts * 8) {
#>
const uint32_t _pt2_unused_<#= num_pt2_tables #>[256] __section_cfg_pt2 __aligned(1024) = {
};
<#
			num_pt2_tables++;
		}

	}
#>

/* MPU settings for all partitions (one per partition) */
const struct arch_mpu_part_cfg mpu_part_cfg[<#=num_cpus + num_parts#>] =
{
<#
	if (gen_pagetables) {
		/* idle partitions share the first partition's page table */
		for (cpu = 0; cpu < num_cpus; cpu++) {
#>
	/* idle partition on CPU <#=cpu#> */ {
		.ttbr0 = (uint32_t)&_pt1_part0,
		.asid = 0,
	},
<#
		}
	} else if (final_run) {
		for (cpu = 0; cpu < num_cpus; cpu++) {
#>
	/* idle partition on CPU <#=cpu#> */
	{
		.<#=region1_name#> =
		{
			/* empty */
		},
<#
			if (split_code_data) {
#>
		.<#=region2_name#> = {
			/* empty */
		},
<#
			}
#>
	},
<#
		}
	}

	if (gen_pagetables) {
		int part_id = 0;
		foreach (XPathNavigator nav in config.Select("/system/partition")) {
			string part_name = nav.GetAttribute("name", "");
#>
	/* partition '<#=part_name#>' */ {
		.ttbr0 = (uint32_t)&_pt1_part<#= part_id #>,
		.asid = <#= part_id+1 #>,
	},
<#
			part_id++;
		}
	} else if (final_run) {
		int mpu_windows_per_partition = 0;
		foreach (XPathNavigator nav in config.Select("/system/partition"))
		{
			string part_name = nav.GetAttribute("name", "");
            string part_cpu_id = nav.GetAttribute("cpu", "");
			mpu_windows_per_partition = config.Select("/memory_layout/part[@name=\""+part_name+"\"]/mpu_window").Count;
#>
	/* partition '<#=part_name#>' on CPU <#= part_cpu_id #> */
	{
		/* <#= mpu_windows_per_partition #> mpu windows generated */
		.<#=region1_name#> =
		{
<#
			foreach (XPathNavigator nav2 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/mpu_window")) {
				gen_window(target_name, mpu_arch, part_cpu_id, 1, nav2, false);
			}
#>
		},
<#
			if (split_code_data) {
#>
		.<#=region2_name#> = {
<#
				foreach (XPathNavigator nav2 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/mpu_window")) {
					gen_window(target_name, mpu_arch, part_cpu_id, 1, nav2, true);
				}
#>
		},
<#
			}
#>
	},
<#
		}
	}
#>
};

/* MPU settings for all tasks (one per task) */
const struct arch_mpu_task_cfg mpu_task_cfg[<#= num_cpus + num_tasks #>] = {
<#
	uint task_table_index = 0;

	if (final_run && !gen_pagetables) {
		for (cpu = 0; cpu < num_cpus; cpu++) {
#>
	/* #<#=task_table_index++#>: idle task on CPU <#=cpu#> */ {
		.<#=region1_name#> = {
			/* empty */
		},
<#
			if (split_code_data) {
#>
		.dpwe = 0,
<#
			}
#>
	},
<#
		}
	}

	if (final_run && !gen_pagetables) {
		foreach (XPathNavigator nav in config.Select("/system/partition")) {
			string part_name = nav.GetAttribute("name", "");
			string part_cpu_id = nav.GetAttribute("cpu", "");
			uint tricore_part_bits = 0;
			int tricore_part_shift = 0;

			/* iterate all partition windows again to find writeable ones */
			if (split_code_data) {
				foreach (XPathNavigator nav2 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/mpu_window")) {
					bool r = Convert.ToInt32(nav2.GetAttribute("read", "")) != 0;
					bool w = Convert.ToInt32(nav2.GetAttribute("write", "")) != 0;
					if (r || w) {
						tricore_part_bits |= (Convert.ToUInt32(w) << tricore_part_shift);
						tricore_part_shift++;
					}
				}
			}

			foreach (XPathNavigator nav2 in config.Select("/system/partition[@name=\""+part_name+"\"]/task")) {
				string task_name = nav2.GetAttribute("name", "");
				uint tricore_task_bits = 0;
				int tricore_task_shift = 10;

#>
	/* #<#=task_table_index++#>: partition '<#=part_name#>' task '<#=task_name#>' */ {
		.<#=region1_name#> = {
<#
				foreach (XPathNavigator nav3 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/task[@name=\""+task_name+"\"]/mpu_window")) {
					bool r = Convert.ToInt32(nav3.GetAttribute("read", "")) != 0;
					bool w = Convert.ToInt32(nav3.GetAttribute("write", "")) != 0;
					if (r || w) {
						tricore_task_bits |= (Convert.ToUInt32(w) << tricore_task_shift);
						tricore_task_shift++;
					}

					gen_window(target_name, mpu_arch, part_cpu_id, 2, nav3, false);
				}
#>
		},
<#
			if (split_code_data) {
				uint u_bits = tricore_task_bits | tricore_part_bits;
#>
		.dpwe = <#= String.Format("0x{0:X8}", u_bits) #>,
<#
			}
#>
	},
<#
			}

			foreach (XPathNavigator nav2 in config.Select("/system/partition[@name=\""+part_name+"\"]/isr")) {
				string isr_name = nav2.GetAttribute("name", "");
				uint tricore_task_bits = 0;
				int tricore_task_shift = 10;

#>
	/* #<#=task_table_index++#>: partition '<#=part_name#>' ISR '<#=isr_name#>' */ {
		.<#=region1_name#> = {
<#
			foreach (XPathNavigator nav3 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/task[@name=\""+isr_name+"\"]/mpu_window")) {
				bool r = Convert.ToInt32(nav3.GetAttribute("read", "")) != 0;
				bool w = Convert.ToInt32(nav3.GetAttribute("write", "")) != 0;
				if (r || w) {
					tricore_task_bits |= (Convert.ToUInt32(w) << tricore_task_shift);
					tricore_task_shift++;
				}

				gen_window(target_name, mpu_arch, part_cpu_id, 2, nav3, false);
			}
#>
		},
<#
			if (split_code_data) {
				uint u_bits = tricore_task_bits | tricore_part_bits;
#>
		.dpwe = <#= String.Format("0x{0:X8}", u_bits) #>,
<#
			}
#>
	},
<#
			}


			foreach (XPathNavigator nav2 in config.Select("/system/partition[@name=\""+part_name+"\"]/hook")) {
				string hook_name = nav2.GetAttribute("name", "");
				uint tricore_task_bits = 0;
				int tricore_task_shift = 10;

#>
	/* #<#=task_table_index++#>: partition '<#=part_name#>' hook '<#=hook_name#>' */ {
		.<#=region1_name#> = {
<#
				foreach (XPathNavigator nav3 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/task[@name=\""+hook_name+"\"]/mpu_window")) {
					bool r = Convert.ToInt32(nav3.GetAttribute("read", "")) != 0;
					bool w = Convert.ToInt32(nav3.GetAttribute("write", "")) != 0;
					if (r || w) {
						tricore_task_bits |= (Convert.ToUInt32(w) << tricore_task_shift);
						tricore_task_shift++;
					}

					gen_window(target_name, mpu_arch, part_cpu_id, 2, nav3, false);
				}
#>
		},
<#
			if (split_code_data) {
				uint u_bits = tricore_task_bits | tricore_part_bits;
#>
		.dpwe = <#= String.Format("0x{0:X8}", u_bits) #>,
<#
			}
#>
	},
<#
			}



			foreach (XPathNavigator nav2 in config.Select("/system/partition[@name=\""+part_name+"\"]/invokable")) {
				string invokable_name = nav2.GetAttribute("name", "");
				uint tricore_task_bits = 0;
				int tricore_task_shift = 10;

#>
	/* #<#=task_table_index++#>: partition '<#=part_name#>' invokable '<#=invokable_name#>' */ {
		.<#=region1_name#> = {
<#
				foreach (XPathNavigator nav3 in config.Select("/memory_layout/part[@name=\""+part_name+"\"]/task[@name=\""+invokable_name+"\"]/mpu_window")) {
					bool r = Convert.ToInt32(nav3.GetAttribute("read", "")) != 0;
					bool w = Convert.ToInt32(nav3.GetAttribute("write", "")) != 0;
					if (r || w) {
						tricore_task_bits |= (Convert.ToUInt32(w) << tricore_task_shift);
						tricore_task_shift++;
					}

					gen_window(target_name, mpu_arch, part_cpu_id, 2, nav3, false);
				}
#>
		},
<#
			if (split_code_data) {
				uint u_bits = tricore_task_bits | tricore_part_bits;
#>
		.dpwe = <#= String.Format("0x{0:X8}", u_bits) #>,
<#
			}
#>
	},
<#
			}


		}
	}
#>
};

<#+
	/**************************************************************************/

	/// FIXME: cannot declare class W in the block above, where it is used
	class W {
		public uint start;
		public uint size;
		public bool user;
		public bool read;
		public bool write;
		public bool exec;
		public bool cached;
		public uint arch;
		public static int CompareByStart(W x, W y) {
			if (x.start < y.start)
				return -1;
			else if (x.start == y.start)
				return 0;
			else
				return 1;
		}
	}

	void gen_window(String target_name, String mpu_arch, String part_cpu_id, int level, XPathNavigator nav, bool is_code)
	{
		string text = nav.GetAttribute("start", "");
		uint start = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);
		text = nav.GetAttribute("size", "");
		uint size = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);
		text = nav.GetAttribute("arch", "");
		uint arch = text.StartsWith("0x") ? Convert.ToUInt32(text.Substring(2), 16) : Convert.ToUInt32(text, 10);
		int id = Convert.ToInt32(nav.GetAttribute("id", ""));

		bool r = Convert.ToInt32(nav.GetAttribute("read", "")) != 0;
		bool w = Convert.ToInt32(nav.GetAttribute("write", "")) != 0;
		bool x = Convert.ToInt32(nav.GetAttribute("exec", "")) != 0;
		bool c = Convert.ToInt32(nav.GetAttribute("cached", "")) != 0;

		if (mpu_arch.Contains("arm_cortexr"))
		{
			gen_arm_cortexr(start, size, arch, r, w, x, c);
		}
		else if (mpu_arch.Contains("arm_cortexm"))
		{
			gen_arm_cortexm(id, level, start, size, arch, r, w, x, c);
		}
		else if (mpu_arch.Contains("ppc_e200"))
		{
			gen_ppc_e200(target_name, mpu_arch, part_cpu_id, start, size, arch, r, w, x, c);
		}
		else if (mpu_arch.Contains("tricore_tc161"))
		{
			if (is_code && !x) {
				return;
			}
			if (!is_code && !r && !w) {
				return;
			}
			gen_tricore_tc161(start, size, arch, r, w, x, c);
		}
		else
		{
			gen_dummy(start, size, arch, r, w, x, c);
		}
	}

	/* generator for ARM Cortex-R4/R5/R7 */
	void gen_arm_cortexr(uint start, uint size, uint arch, bool r, bool w, bool x, bool c)
	{
		uint bas = start;
		uint siz = ((uint)(Math.Log(size) / Math.Log(2))-1 << 1) | 1;
		uint acc = 0;
		if (!x) {
			acc = 1 << 12;	// XN bit
		}

		// user window: supervisor has same access than user
		if (w) {
			acc |= 0x3 << 8;	// read-write
		} else {
			acc |= 0x6 << 8;	// read-only
		}

		// cache attributes
		if (c) {
			// FIXME: hardcoded: WBWA caching, non-shared
			acc |= 0xb;	// TEX S CB = 001 0 11
		} else {
			// uncached, strongly-ordered
			acc |= 0x0;	// TEX S CB = 000 0 00
		}
#>
			{ .base = <#= String.Format("0x{0:X8}", bas) #>, .size_enable = <#= String.Format("0x{0:X8}", siz) #>, .access_control = <#= String.Format("0x{0:X8}", acc) #> },
<#+
	}

	/* generator for ARM Cortex-M3/M4/M7 */
	void gen_arm_cortexm(int id, int level, uint start, uint size, uint arch, bool r, bool w, bool x, bool c)
	{
		uint bas = start;
		uint siz = ((uint)(Math.Log(size) / Math.Log(2))-1 << 1) | 1;
		uint acc = 0;
		if (!x) {
			acc = 1 << 28;	// XN bit
		}

		// user window: supervisor has same access than user
		if (w) {
			acc |= 0x3 << 24;	// read-write
		} else {
			acc |= 0x6 << 24;	// read-only
		}

		if (bas >= 0x00000000 && bas < 0x20000000) {
			// internal Flash
			acc |= 0x2 << 16;	// TEX S CB = 000 0 10
		} else if (bas >= 0x20000000 && bas < 0x40000000) {
			// internal SRAM
			acc |= 0x6 << 16;	// TEX S CB = 000 1 10
		} else if (bas >= 0x60000000 && bas < 0xa0000000) {
			// external RAM
			acc |= 0x7 << 16;	// TEX S CB = 000 1 11
		} else {
			// peripheral
			acc |= 0x5 << 16;	// TEX S CB = 000 1 01
		}

		if (level == 2) {
			// task window has ID 7, we only have 8 windows
			id = 7;
		}
		bas |= 0x10 | (uint)id;	 // set ENABLE and id

		if (level == 0) {
			// ignore kernel windows
			return;
		}
#>
			{ .base_region_valid = <#= String.Format("0x{0:X8}", bas) #>, .attrib_size_enable = <#= String.Format("0x{0:X8}", siz | acc) #> },
<#+
	}

	/* generator for PPC e200 MMU */
	void gen_ppc_e200(String target_name, String mpu_arch, String part_cpu_id, uint start, uint size, uint arch, bool r, bool w, bool x, bool c)
	{
		uint mas1 = 0x80000000 | (0 << 16) | (((uint)(Math.Log(size) / Math.Log(2))-10) << 7);
		uint mas2 = start;
		uint mas3 = start;
		/* Contents of an ACCSET field in the SMPUx_RGDn_WRD3 register */
		uint permissions = 0;

		// use translation space //1 for user mappings
		mas1 |= 0x1000;

		// cache attributes
		// FIXME: hardcoded: WB caching, no memory coherency, big-endian
		mas2 |= 0x00;

		// access permissions
		if (r) {
			mas3 |= 0x02;	// user exec, supervisor no read
			permissions |= 0x04; // user read access
		}
		if (w) {
			mas3 |= 0x08;	// user exec, supervisor no write
			permissions |= 0x02; // user write access
		}
		if (x) {
			mas3 |= 0x20;	// user exec, supervisor no exec
			permissions |= 0x01; // user exec access
		}
		if (target_name.Contains("MPC5748G"))
		{
#>
			{
			  .start_address   = <#= String.Format("0x{0:X8}", start) #>,
			  .end_address     = <#= String.Format("0x{0:X8}", start + size) #>,
<#+
			if (mpu_arch.Contains("multicore"))
			{
				int cpu = Int32.Parse(part_cpu_id);
#>
			  /* cpu <#= part_cpu_id #> and its debug master point to ACCSET1 */
			  .access_pointers = <#= String.Format("0x{0:X8}", (0x40000000 >> (cpu * 2)) | (0x00800000 >> (cpu * 2))) #>,
<#+
			}
			else
			{
#>
			  /* All busmasters point to ACCSET1 */
			  .access_pointers = 0x55555555u,
<#+
			}
#>
			  /* ACCSET1: user read = <#= r? 1 : 0 #>, user write = <#= w? 1 : 0 #>, user exec = <#= x? 1 : 0 #>, format = 1 */
			  .permissions     = <#= String.Format("0x{0:X8}", (permissions << 26) | 0x10) #>
			},
<#+
		}
		else
		{
#>
			{ .mas1 = <#= String.Format("0x{0:X8}", mas1) #>, .mas2 = <#= String.Format("0x{0:X8}", mas2) #>, .mas3 = <#= String.Format("0x{0:X8}", mas3) #> },
<#+
		}
	}

	/* generator for Tricore TC161 MPU */
	void gen_tricore_tc161(uint start, uint size, uint arch, bool r, bool w, bool x, bool c)
	{
		uint lower = start;
		uint upper = start + size;

#>
			{ .lower = <#= String.Format("0x{0:X8}", lower) #>, .upper = <#= String.Format("0x{0:X8}", upper) #> },
<#+
	}

	/* generator for dummy entries */
	void gen_dummy(uint start, uint size, uint arch, bool r, bool w, bool x, bool c)
	{
#>
			/* dummy */
<#+
	}
#>
