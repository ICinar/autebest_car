/*
 * board.c
 *
 * Board initialization for TMS 570.
 *
 * azuepke, 2013-11-19: initial cloned
 * azuepke, 2014-04-29: proper clock handling
 */

#include <kernel.h>
#include <assert.h>
#include <arm_insn.h>
#include <board.h>
#include <arm_private.h>
#include <arm_io.h>
#include <board_stuff.h>
#include <rti_timer.h>
#include <linker.h>
#include <gio.h>
#include <hm.h>


__cold void board_halt(haltmode_t mode __unused)
{
	/* FIXME: no reset defined */

	/* just halt the machine */
	__board_halt();
}

void board_idle(void)
{
	while (1) {
		__board_idle();
	}
}

void __init board_mpu_init(void)
{
	/* on TMS570, the kernel runs with MPU disabled */
}

void __init board_cpu0_up(void)
{
}

void __init board_startup_complete(void)
{
}

void board_nmi_dispatch(unsigned int vector __unused)
{
	hm_system_error(HM_ERROR_NMI, vector);
}

int board_hm_exception(
	struct arch_reg_frame *regs __unused,
	int fatal __unused,
	unsigned int hm_error_id __unused,
	unsigned long vector __unused,
	unsigned long fault_addr __unused,
	unsigned long aux __unused)
{
	return 0;	/* exception not handled */
}

void board_tp_switch(
	unsigned int prev_timepart __unused,
	unsigned int next_timepart __unused,
	unsigned int tpwindow_flags __unused)
{
}

/** kernel entry function */
void __init board_init(void)
{
	/* the steps for hardware initialization follow the reference code
	 * generated by HalCoGen v03.06.00
	 */

	setup_pll();

	periph_init();

	mux_init();

	setup_flash();

	trim_LPO();

	/** Wait for PLLs to start up and map clock domains to desired clock sources */
	map_clocks();

	set_eclk();

#if 0
	// ... memory self tests ...

	/* Enable IRQ offset via Vic controller */
	//_coreEnableIrqVicOffset_();

	/* Initialize VIM table */
	//vimInit();

	/* Configure system response to error conditions signaled to the ESM group1 */
	/* This function can be configured from the ESM tab of HALCoGen */
	//esmInit();
#endif

#if 1
	/* enable interrupt for GIO A7 pin on the Hercules board */

	/* enable GIO module */
	gioREG->GCR0 = 0x01;
	gioREG->INTENACLR = 0xffffffff;
	gioREG->LVLCLR = 0xffffffff;

	/* keep port settings to defaults (input mode) */

	/* keep default interrupt settings (single edge + falling edge) */

	/* keep interrupts in low prio mode: IRQ 23 (low) instead of IRQ 9 (high) */

	/* clear all pending interrupts */
	gioREG->FLG = 0xffffffff;

	/* enable interrupt for GIO A7 */
	gioREG->INTENASET = (1u<<7);

	// FIXME: read offset1 to clear the interrupt
	// read 0xfff7bc28: 0 no interrupts, 1..32 -> interrupt src
#endif

	serial_init(115200);
	printf("Starting up ...\n");

	printf("assuming ROM from %08x to %08x\n", BOARD_ROM_PHYS, BOARD_ROM_PHYS + BOARD_ROM_SIZE);
	printf("     kernel .text %08x to %08x\n", (int)__text_start, (int)__text_end);
	printf("assuming RAM from %08x to %08x\n", BOARD_RAM_PHYS, BOARD_RAM_PHYS + BOARD_RAM_SIZE);
	printf("     kernel .data %08x to %08x\n", (int)__data_start, (int)__data_end);
	printf("     kernel .bss  %08x to %08x\n", (int)__bss_start, (int)__bss_end);

	rti_timer_init(100);

	/* enter the kernel */
	kernel_main(0);
}
