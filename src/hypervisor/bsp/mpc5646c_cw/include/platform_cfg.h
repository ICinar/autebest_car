/**
 * \file
 *
 * \brief easycore Crypto Library
 *
 * This file contains generic implementation for the platform specific parts.
 * For performance improvements, a platform specific header file may be used, 
 * which implements all or parts of the functionality with more specialized 
 * code or even in assembler.
 * 
 * The default implementation uses only 32 bit operations. A relatively
 * easy optimization for a lot of platforms would be an optimized implementation
 * of this file, e.g. using 64 or 128 bit registers and operations.
 *
 * \author Bernhard Jungk, easycore GmbH, 91058 Erlangen, Germany
 *
 * \par License
 * Customer: @@LicenseCustomer@@,
 * License type: @@LicenseType@@,
 * Licensed for project: @@LicenseProject@@.
 *
 * Copyright 2014 easycore GmbH
 * All rights exclusively reserved for easycore GmbH, unless expressly agreed to otherwise.
 */

/*
 * -- AUTOGENERATED -- DO NOT EDIT --
 */

#ifndef EC_CRYPT_GENERIC_PLATFORM_CFG_H
#define EC_CRYPT_GENERIC_PLATFORM_CFG_H

/*==================[inclusions]============================================*/

#include <types_cfg.h>
#include <common.h>

/* include for memset/memcpy */
#include <string.h>

/*==================[macros]================================================*/

#ifndef __ORDER_BIG_ENDIAN__  
#define __ORDER_BIG_ENDIAN__ 4321
#endif

#ifndef __ORDER_LITTLE_ENDIAN__
#define __ORDER_LITTLE_ENDIAN__ 1234
#endif

#ifndef __BYTE_ORDER__
#define __BYTE_ORDER__ __ORDER_BIG_ENDIAN__
#endif

/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/

/**
 * \brief Byte-wise compare of len bytes of the memory pointed to by lhsPtr and rhsPtr. If both 
 *        memory locations are identical, then the return value is 0. If the first byte that 
 *        differs has a lower value in lhsPtr, then -1 is return, otherwise +1.
 *
 * \param lhsPtr A pointer to a first buffer.
 * \param rhsPtr A pointer to a second buffer.
 * \param len The length of the memory to be compared.
 *
 * \return 0, if for all len bytes i, lhsPtr[i]==rhsPtr[i].
 *         -1, if for the first difference at position i lhsPtr{i]<rhsPtr{i].
 *         +1, if for the first difference at position i lhsPtr{i]>rhsPtr{i].
 */
static inline sint8 EC_Crypt_Compare
(
   const void* lhsPtr,
   const void* rhsPtr,
   uint32      len
);

/**
 * \brief Reset the buffer destPtr to 0.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param destPtr A pointer to a destination buffer.
 * \param len The length of the memory to be copied.
 */
static inline void EC_Crypt_ResetBuffer
(
   void*  destPtr,
   uint32 len
);

/**
 * \brief Copy len bytes from srcPtr to destPtr.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param destPtr A pointer to a destination buffer.
 * \param srcPtr A pointer to a source buffer.
 * \param len The length of the memory to be copied.
 */
static inline void EC_Crypt_Copy
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
);

/**
 * \brief Copy len bytes from srcPtr to destPtr and change the byte order
 *        to little endian.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param destPtr A pointer to a destination buffer.
 * \param srcPtr A pointer to a source buffer.
 * \param len The length of the memory to be copied.
 */
static inline void EC_Crypt_CopyHostToLE
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
);

/**
 * \brief Copy len bytes from srcPtr to destPtr and change the byte order
 *        to big endian.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param destPtr A pointer to a destination buffer.
 * \param srcPtr A pointer to a source buffer.
 * \param len The length of the memory to be copied.
 */
static inline void EC_Crypt_CopyHostToBE
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
);

/**
 * \brief
 * 
 * \param inputPtr
 * \param inputLen
 * \param inputOffset
 * \param bufferPtr
 * \param bufferLen
 * \param bufferedBytes
 * \param copiedBytesPtr
 */
static inline void EC_Crypt_BufferDataLEToHost
(
  const void* inputPtr,
  uint32      inputLen,
  uint32      inputOffset,
  void*       bufferPtr,
  uint32      bufferLen,
  uint32      bufferedBytes,
  uint32*     copiedBytesPtr
);

/**
 * \brief
 * 
 * \param inputPtr
 * \param inputLen
 * \param inputOffset
 * \param bufferPtr
 * \param bufferLen
 * \param bufferedBytes
 * \param copiedBytesPtr
 */
static inline void EC_Crypt_BufferDataBEToHost
(
  const void* inputPtr,
  uint32      inputLen,
  uint32      inputOffset,
  void*       bufferPtr,
  uint32      bufferLen,
  uint32      bufferedBytes,
  uint32*     copiedBytesPtr
);

/**
 * \brief Rotate the data to the left by sh bits. The data is interpreted
 *        as 32 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 31
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROL32
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the left by sh bits. The data is interpreted
 *        as 64 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 63
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROL64
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the left by sh bits. The data is interpreted
 *        as 64 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 63
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROL64Copy
(
  void* out,
  void* data,
  uint32 sh
);


/**
 * \brief Rotate the data to the left by sh bits. The data is interpreted
 *        as 80 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 79
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROL80
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the left by sh bits. The data is interpreted
 *        as 128 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 127
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROL128
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the right by sh bits. The data is interpreted
 *        as 32 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 31
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROR32
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the right by sh bits. The data is interpreted
 *        as 64 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 63
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROR64
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the right by sh bits. The data is interpreted
 *        as 80 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 79
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROR80
(
  void* data,
  uint32 sh
);

/**
 * \brief Rotate the data to the right by sh bits. The data is interpreted
 *        as 128 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 127
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_ROR128
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the left by sh bits. The data is interpreted
 *        as 32 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 31
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHL32
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the left by sh bits. The data is interpreted
 *        as 64 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 63
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHL64
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the left by sh bits. The data is interpreted
 *        as 128 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 127
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHL128
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the right by sh bits. The data is interpreted
 *        as 32 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 *  
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 31
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHR32
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the right by sh bits. The data is interpreted
 *        as 64 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 63
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHR64
(
  void* data,
  uint32 sh
);

/**
 * \brief Shift the data to the right by sh bits. The data is interpreted
 *        as 128 bit wide unsigned int in host byte order.
 *
 * \TODO Implement alignment checks in debug mode.
 * 
 * \param data  The data to be rotated.
 * \param sh    The number of bits to be shifted. The value must be between 1 and 127
 *              to work reliable on all platforms. 
 */
static inline void EC_Crypt_SHR128
(
  void* data,
  uint32 sh
);

/**
 * \brief Implements a 32 bit wide XOR.
 *
 * \TODO Implement alignment checks in debug mode.
 *
 * \param dest Memory destination.
 * \param lhs Left hand side of the XOR operation.
 * \param rhs Right hand side of the XOR operation.
 */
static inline void EC_Crypt_XOR32
(
  void* dest,
  const void* lhs,
  const void* rhs
);

/**
 * \brief Implements a 64 bit wide XOR.
 *
 * \TODO Implement alignment checks in debug mode.
 *
 * \param dest Memory destination.
 * \param lhs Left hand side of the XOR operation.
 * \param rhs Right hand side of the XOR operation.
 */
static inline void EC_Crypt_XOR64
(
  void* dest,
  const void* lhs,
  const void* rhs
);

/**
 * \brief Implements a 128 bit wide XOR.
 *
 * \TODO Implement alignment checks in debug mode.
 *
 * \param dest Memory destination.
 * \param lhs Left hand side of the XOR operation.
 * \param rhs Right hand side of the XOR operation.
 */
static inline void EC_Crypt_XOR128
(
  void* dest,
  const void* lhs,
  const void* rhs
);

/**
 * \brief Implements a byte-wise byte access to a buffer. The logical byte order is assumed to be 
 *        big endian, i.e. 0 is the most significant byte. 
 *        
 * This is different from a direct byte access, if an algorithm interprets the byte order as 
 * big endian, but the host platform is a little endian target.  
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer. 
 * \param pos The number of the byte to return.
 */
static inline uint8 EC_Crypt_GetByteBE
(
  const uint8 *data,
  uint32 len,
  uint32 pos
);

/**
 * \brief 
 * 
 * \param dataPtr
 * \param len
 * \param newData
 * \param pos
 */
static inline void EC_Crypt_SetByteBE
(
  uint8 *dataPtr,
  uint32 len,
  uint8 newData,
  uint32 pos
);

/**
 * \brief Implements a byte-wise byte access to a buffer. The logical byte order is assumed to be 
 *        little endian, i.e. 0 is the most significant byte. 
 *        
 * This is different from a direct byte access, if an algorithm interprets the byte order as 
 * little endian, but the host platform is a big endian target.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer. 
 * \param pos The number of the byte to return.
 */
static inline uint8 EC_Crypt_GetByteLE
(
  const uint8 *data,
  uint32 len,
  uint32 pos
);

/**
 * \brief 
 * 
 * \param dataPtr
 * \param len
 * \param newData
 * \param pos
 */
static inline void EC_Crypt_SetByteLE
(
  uint8 *dataPtr,
  uint32 len,
  uint8 newData,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is little endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline uint32 EC_Crypt_GetWord32LE
(
  const uint32 *dataPtr,
  uint32 len,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is little endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline void EC_Crypt_SetWord32LE
(
  uint32 *dataPtr,
  uint32 len,
  uint32 newData,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is big endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline uint32 EC_Crypt_GetWord32BE
(
  const uint32 *dataPtr,
  uint32 len,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is big endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline void EC_Crypt_SetWord32BE
(
  uint32 *dataPtr,
  uint32 len,
  uint32 newData,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is little endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline uint64 EC_Crypt_GetWord64LE
(
  const uint64 *dataPtr,
  uint32 len,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is little endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline void EC_Crypt_SetWord64LE
(
  uint64 *dataPtr,
  uint32 len,
  uint64 newData,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is big endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline uint64 EC_Crypt_GetWord64BE
(
  const uint64 *dataPtr,
  uint32 len,
  uint32 pos
);

/**
 * \brief Implements a 32 bit word access to a buffer. The original interpretation of the data
 *        is big endian.
 * 
 * \param data The buffer to be accessed.
 * \param len The length of the buffer in bytes. 
 * \param pos The number of the word to return.
 */
static inline void EC_Crypt_SetWord64BE
(
  uint64 *dataPtr,
  uint32 len,
  uint64 newData,
  uint32 pos
);

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
/*==================[external function definitions]==========================*/
/*==================[internal function definitions]==========================*/



/*------------------[big endian copy]---------------------------------------*/
   
static inline void EC_Crypt_CopyHostToLE
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
)
{
  uint32 i;
  uint8* const destPtr_u8 = (uint8* const) destPtr;
  const uint8* const srcPtr_u8 = (const uint8* const) srcPtr;

  for(i = 0; i < len; i++)
  {
    destPtr_u8[i] = srcPtr_u8[len-i-1];
  }
}

static inline void EC_Crypt_CopyHostToBE
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
)
{
  EC_Crypt_Copy(destPtr,
                srcPtr,
                len);
}

static inline void EC_Crypt_CopyBEToHost
(
  void*       destPtr,
  const void* srcPtr,
  uint32      len
)
{
  EC_Crypt_Copy(destPtr, 
                srcPtr, 
                len);
}

static inline void EC_Crypt_CopyLEToHost
(
  void*       destPtr,
  const void* srcPtr,
  uint32      len
)
{
  EC_Crypt_CopyHostToLE(destPtr,
                        srcPtr,
                        len);
}

static inline void EC_Crypt_BufferDataLEToHost
(
  const void* inputPtr,
  uint32      inputLen,
  uint32      inputOffset,
  void*       bufferPtr,
  uint32      bufferLen,
  uint32      bufferedBytes,
  uint32*     copiedBytesPtr
)
{
  const uint8* inputPtr_u8;
  uint8* bufferPtr_u8;
  
  /* copy the minimum of
   *  - the number of bytes until the buffer is full and
   *  - the remaining bytes of the input message
   */
  *copiedBytesPtr = EC_CRYPT_MIN(bufferLen - bufferedBytes,
                                 inputLen - inputOffset);

  inputPtr_u8 = (const uint8*) inputPtr;
  bufferPtr_u8 = (uint8*) bufferPtr;

  EC_Crypt_CopyLEToHost(&bufferPtr_u8[bufferLen - *copiedBytesPtr - bufferedBytes],
                        &inputPtr_u8[inputOffset],
                        *copiedBytesPtr);
}

static inline void EC_Crypt_BufferDataBEToHost
(
  const void* inputPtr,
  uint32      inputLen,
  uint32      inputOffset,
  void*       bufferPtr,
  uint32      bufferLen,
  uint32      bufferedBytes,
  uint32*     copiedBytesPtr
)
{
  const uint8* inputPtr_u8;
  uint8* bufferPtr_u8;


  /* copy the minimum of
   *  - the number of bytes until the buffer is full and
   *  - the remaining bytes of the input message
   */
  *copiedBytesPtr = EC_CRYPT_MIN(bufferLen - bufferedBytes,
                                 inputLen - inputOffset);

  inputPtr_u8 = (const uint8*) inputPtr;
  bufferPtr_u8 = (uint8*) bufferPtr;

  EC_Crypt_CopyBEToHost(&bufferPtr_u8[bufferedBytes],
                        &inputPtr_u8[inputOffset],
                        *copiedBytesPtr);
}

/*------------------[little endian copy]------------------------------------*/


/*------------------[host byte order copy]----------------------------------*/

static inline void EC_Crypt_Copy
(
   void*       destPtr,
   const void* srcPtr,
   uint32      len
)
{
  memcpy(destPtr, srcPtr, len);
}

/*-----------------[platform specific memset to 0]--------------------------*/

static inline void EC_Crypt_ResetBuffer
(
   void*  destPtr,
   uint32 len
)
{
  memset(destPtr, 0, len); 
}

static inline sint8 EC_Crypt_Compare
(
   const void* lhsPtr,
   const void* rhsPtr,
   uint32      len
)
{
  /* warning: the comparison will return different results for litte and big endian platforms, 
   * if the byte order matters. */
  return memcmp(lhsPtr, rhsPtr, len);
} 

/*------------------[byte order agnostic rotates and shifts]----------------*/

static inline void EC_Crypt_ROL32
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  /* Many compilers generate a 32 bit rotate instruction from this code. */
  dataPtr[0] = (dataPtr[0] << sh) | (dataPtr[0] >> (32-sh));
}

static inline void EC_Crypt_ROL64
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  uint32 tmp[2];
  tmp[0] = dataPtr[0];
  tmp[1] = dataPtr[1];
  
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[0] = ((tmp[0] << sh) | (tmp[1] >> (32-sh)));
    dataPtr[1] = ((tmp[1] << sh) | (tmp[0] >> (32-sh)));
  } else if(sh == 32) {
    dataPtr[0] = tmp[1];
    dataPtr[1] = tmp[0];
  } else if(sh < 64) {
    dataPtr[0] = ((tmp[1] << (sh - 32)) | (tmp[0] >> (64 - sh)));
    dataPtr[1] = ((tmp[0] << (sh - 32)) | (tmp[1] >> (64 - sh)));
  }
}

static inline void EC_Crypt_ROL64Copy
(
  void* out,
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  uint32* outPtr = (uint32*) out;
  
  if(sh == 0) {
    outPtr[0] = dataPtr[0];
    outPtr[1] = dataPtr[1];
  } else if(sh < 32) {
    outPtr[0] = ((dataPtr[0] << sh) | (dataPtr[1] >> (32-sh)));
    outPtr[1] = ((dataPtr[1] << sh) | (dataPtr[0] >> (32-sh)));
  } else if(sh == 32) {
    outPtr[0] = dataPtr[1];
    outPtr[1] = dataPtr[0];
  } else if(sh < 64) {
    outPtr[0] = ((dataPtr[1] << (sh - 32)) | (dataPtr[0] >> (64 - sh)));
    outPtr[1] = ((dataPtr[0] << (sh - 32)) | (dataPtr[1] >> (64 - sh)));
  }
}

static inline void EC_Crypt_ROR32
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  /* Many compilers generate a 32 bit rotate instruction from this code. */
  dataPtr[0] = (dataPtr[0] >> sh) | (dataPtr[0] << (32-sh));  
}


static inline void EC_Crypt_ROR64
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  uint32 tmp[2];
  tmp[0] = dataPtr[0];
  tmp[1] = dataPtr[1];

  
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[0] = ((tmp[0] >> sh) | (tmp[1] << (32-sh)));
    dataPtr[1] = ((tmp[1] >> sh) | (tmp[0] << (32-sh)));
  } else if(sh == 32) {
    dataPtr[0] = tmp[1];
    dataPtr[1] = tmp[0];
  } else if(sh < 64) {
    dataPtr[0] = ((tmp[1] >> (sh - 32)) | (tmp[0] << (64 - sh)));
    dataPtr[1] = ((tmp[0] >> (sh - 32)) | (tmp[1] << (64 - sh)));
  }
}

static inline void EC_Crypt_SHL32
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  /* Many compilers generate a 32 bit rotate instruction from this code. */
  dataPtr[0] = dataPtr[0] << sh;    
}

static inline void EC_Crypt_SHR32
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  /* Many compilers generate a 32 bit rotate instruction from this code. */
  dataPtr[0] = dataPtr[0] >> sh;  
}


/*------------------[big endian rotates and shifts]-------------------------*/

static inline void EC_Crypt_ROL80
(
  void* data,
  uint32 sh
)
{
  /* TODO needs serious review for big endianess. */
  uint32* dataPtr32 = (uint32*) data;
  uint16* dataPtr16 = (uint16*) data;

  uint32 tmp[2];

  tmp[0] = dataPtr32[0];
  tmp[1] = dataPtr32[1];  
  
  /* a generic 80 bit rotate is awkward to implement... */
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 16) {
    dataPtr32[0] = ((tmp[0]          << sh)              | (tmp[1]                   >> (32-sh)));
    dataPtr32[1] = ((tmp[1]          << sh)              | ((((uint32) dataPtr16[4]) >> (16-sh))));
    dataPtr16[4] = ((dataPtr16[4]    << sh)              | ((uint16) (tmp[0]         >> (32-sh))));
  } else if(sh == 16) {
    dataPtr32[0] = ((tmp[0]          << 16)              | ((tmp[1]                  >> 16)));
    dataPtr32[1] = ((tmp[1]          << 16)              | ((((uint32) dataPtr16[4]))));
    dataPtr16[4] = (uint16) (tmp[0]  >> 16);
  } else if(sh < 32) {
    dataPtr32[0] = ((tmp[0]          << sh)              | (tmp[1]                   >> (32-sh)));
    dataPtr32[1] = ((tmp[1]          << sh)              | ((((uint32) dataPtr16[4]) << (sh-16)))
                 | ((tmp[0]          >> (48-sh))));        
    dataPtr16[4] = (uint16) (tmp[0]  >> (32-sh));
  } else if(sh == 32) {
    dataPtr32[0] = tmp[1];
    dataPtr32[1] = ((((uint32) dataPtr16[4]) << (sh-16)) | (tmp[0]                   >> 16));        
    dataPtr16[4] = (uint16) tmp[0];  
  } else if(sh < 48) {
    dataPtr32[0] = (tmp[1]           << (sh-32))         | ((((uint32) dataPtr16[4]) >> (48-sh)));                                 
    dataPtr32[1] = ((((uint32) dataPtr16[4]) << (sh-16)) | (tmp[0]                   >> (48-sh)));
    dataPtr16[4] = ((uint16) (tmp[0] << (sh-32))         | ((uint16) (tmp[1]         >> (64-sh))));
  } else if(sh == 48) {
    dataPtr32[0] = tmp[1]            << 16               | (uint32) dataPtr16[4];                          
    dataPtr32[1] = tmp[0];
    dataPtr16[4] = (uint16) (tmp[1]  >> 16);
  } else if(sh < 64) {
    dataPtr32[0] = (((tmp[1]         << (sh-32))         | ((uint32) dataPtr16[4])   << (sh-48))
                 | ((tmp[0]          >> (80-sh))));
    dataPtr32[1] = ((tmp[0]          << (sh-48))         | (tmp[1]                   >> (80-sh)));
    dataPtr16[4] = ((uint16) (tmp[1] >> (64-sh)));
  } else if(sh == 64) {
    dataPtr32[0] = ((((uint32) dataPtr16[4]) << 16)      | (tmp[0]                   >> 16));
    dataPtr32[1] = ((tmp[0]          << 16)              | (tmp[1]                   >> 16));
    dataPtr16[4] = (uint16) tmp[1];
  } else if(sh < 80) {
    dataPtr32[0] = ((((uint32) dataPtr16[4]) << (sh-48)) | ((tmp[0]                  >> (80-sh))));
    dataPtr32[1] = ((tmp[0]          << (sh-48))         | (tmp[1]                   >> (80-sh)));
    dataPtr16[4] = ((uint16) (tmp[1] << (sh-64))         | (dataPtr16[4]             >> (80-sh)));
  }
}

static inline void EC_Crypt_ROL128
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  uint32 tmp[4];

  tmp[0] = dataPtr[0];
  tmp[1] = dataPtr[1];
  tmp[2] = dataPtr[2];
  tmp[3] = dataPtr[3];
  
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[0] = (tmp[0] << sh) | (tmp[1] >> (32-sh));
    dataPtr[1] = (tmp[1] << sh) | (tmp[2] >> (32-sh));
    dataPtr[2] = (tmp[2] << sh) | (tmp[3] >> (32-sh));
    dataPtr[3] = (tmp[3] << sh) | (tmp[0] >> (32-sh));
  } else if(sh == 32) {
    tmp[3] = dataPtr[3];
    dataPtr[0] = tmp[1];
    dataPtr[1] = tmp[2];
    dataPtr[2] = tmp[3];
    dataPtr[3] = tmp[0];
  } else if(sh < 64) {
    dataPtr[0] = (tmp[1] << (sh-32)) | (tmp[2] >> (64-sh));
    dataPtr[1] = (tmp[2] << (sh-32)) | (tmp[3] >> (64-sh));
    dataPtr[2] = (tmp[3] << (sh-32)) | (tmp[0] >> (64-sh));
    dataPtr[3] = (tmp[0] << (sh-32)) | (tmp[1] >> (64-sh));
  } else if(sh == 64) {
    dataPtr[0] = tmp[2];
    dataPtr[1] = tmp[3];
    dataPtr[2] = tmp[0];
    dataPtr[3] = tmp[1];
  } else if(sh < 96) {
    dataPtr[0] = (tmp[2] << (sh-64)) | (tmp[3] >> (96-sh));
    dataPtr[1] = (tmp[3] << (sh-64)) | (tmp[0] >> (96-sh));
    dataPtr[2] = (tmp[0] << (sh-64)) | (tmp[1] >> (96-sh));
    dataPtr[3] = (tmp[1] << (sh-64)) | (tmp[2] >> (96-sh));
  } else if(sh == 96) {
    dataPtr[0] = tmp[3];
    dataPtr[1] = tmp[0];
    dataPtr[2] = tmp[1];
    dataPtr[3] = tmp[2];
  } else if(sh < 128) {
    dataPtr[0] = (tmp[3] << (sh-96)) | (tmp[0] >> (128-sh));
    dataPtr[1] = (tmp[0] << (sh-96)) | (tmp[1] >> (128-sh));
    dataPtr[2] = (tmp[1] << (sh-96)) | (tmp[2] >> (128-sh));
    dataPtr[3] = (tmp[2] << (sh-96)) | (tmp[3] >> (128-sh));
  } 
}

static inline void EC_Crypt_ROR80
(
  void* data,
  uint32 sh
)
{
  EC_Crypt_ROL80(data, (80-sh) % 80);
}

static inline void EC_Crypt_ROR128
(
  void* data,
  uint32 sh
)
{
  EC_Crypt_ROL128(data, (128-sh) % 128);
}

static inline void EC_Crypt_SHL64
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;

  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[0] = (dataPtr[0] << sh) | (dataPtr[1] >> (32-sh));
    dataPtr[1] = (dataPtr[1] << sh);
  } else if(sh == 32) {
    dataPtr[0] = dataPtr[1];
    dataPtr[1] = 0;
  } else if(sh < 64) {
    dataPtr[0] = (dataPtr[1] << (sh - 32));
    dataPtr[1] = 0;
  }
}

static inline void EC_Crypt_SHL128
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[0] = (dataPtr[0] << sh) | (dataPtr[1] >> (32-sh));
    dataPtr[1] = (dataPtr[1] << sh) | (dataPtr[2] >> (32-sh));
    dataPtr[2] = (dataPtr[2] << sh) | (dataPtr[3] >> (32-sh));
    dataPtr[3] = (dataPtr[3] << sh);
  } else if(sh == 32) {
    dataPtr[0] = dataPtr[1];
    dataPtr[1] = dataPtr[2];
    dataPtr[2] = dataPtr[3];
    dataPtr[3] = 0;
  } else if(sh < 64) {
    dataPtr[0] = (dataPtr[1] << (sh-32)) | (dataPtr[2] >> (64-sh));
    dataPtr[1] = (dataPtr[2] << (sh-32)) | (dataPtr[3] >> (64-sh));
    dataPtr[2] = (dataPtr[3] << (sh-32));
    dataPtr[3] = 0;
  } else if(sh == 64) {
    dataPtr[0] = dataPtr[2];
    dataPtr[1] = dataPtr[3];
    dataPtr[2] = 0;
    dataPtr[3] = 0;
  } else if(sh < 96) {
    dataPtr[0] = (dataPtr[2] << (sh-64)) | (dataPtr[3] >> (96-sh));
    dataPtr[1] = (dataPtr[3] << (sh-64));
    dataPtr[2] = 0;
    dataPtr[3] = 0;
  } else if(sh == 96) {
    dataPtr[0] = dataPtr[3];
    dataPtr[1] = 0;
    dataPtr[2] = 0;
    dataPtr[3] = 0;
  } else if(sh < 128) {
    dataPtr[0] = (dataPtr[3] << (sh-96));
    dataPtr[1] = 0;
    dataPtr[2] = 0;
    dataPtr[3] = 0;
  } 
}

static inline void EC_Crypt_SHR64
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;

  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[1] = (dataPtr[1] >> sh) | (dataPtr[0] << (32 - sh));
    dataPtr[0] = (dataPtr[0] >> sh);
  } else if(sh == 32) {
    dataPtr[1] = dataPtr[0];
    dataPtr[0] = 0;
  } else if(sh < 64) {
    dataPtr[1] = (dataPtr[0] >> (sh - 32));
    dataPtr[0] = 0;
  }
}

static inline void EC_Crypt_SHR128
(
  void* data,
  uint32 sh
)
{
  uint32* dataPtr = (uint32*) data;
  
  if(sh == 0) {
    /* do nothing */
  } else if(sh < 32) {
    dataPtr[3] = (dataPtr[3] >> sh) | (dataPtr[2] << (32 - sh));
    dataPtr[2] = (dataPtr[2] >> sh) | (dataPtr[1] << (32 - sh));
    dataPtr[1] = (dataPtr[1] >> sh) | (dataPtr[0] << (32 - sh));
    dataPtr[0] = (dataPtr[0] >> sh);
  } else if(sh == 32) {
    dataPtr[3] = dataPtr[2];
    dataPtr[2] = dataPtr[1];
    dataPtr[1] = dataPtr[0];
    dataPtr[0] = 0;
  } else if(sh < 64) {
    dataPtr[3] = (dataPtr[2] >> (sh-32)) | (dataPtr[1] << (64-sh));
    dataPtr[2] = (dataPtr[1] >> (sh-32)) | (dataPtr[0] << (64-sh));
    dataPtr[1] = (dataPtr[0] >> (sh-32));
    dataPtr[0] = 0;
  } else if(sh == 64) {
    dataPtr[3] = dataPtr[1];
    dataPtr[2] = dataPtr[0];
    dataPtr[1] = 0;
    dataPtr[0] = 0;
  } else if(sh < 96) {
    dataPtr[3] = (dataPtr[1] >> (sh-64)) | (dataPtr[0] << (96-sh));
    dataPtr[2] = (dataPtr[0] >> (sh-64));
    dataPtr[1] = 0;
    dataPtr[0] = 0;
  } else if(sh == 96) {
    dataPtr[3] = dataPtr[0];
    dataPtr[2] = 0;
    dataPtr[1] = 0;
    dataPtr[0] = 0;
  } else if(sh < 128) {
    dataPtr[3] = (dataPtr[0] >> (sh-96));
    dataPtr[2] = 0;
    dataPtr[1] = 0;
    dataPtr[0] = 0;
  } 
}

static inline uint8 EC_Crypt_GetByteBE
(
  const uint8 *dataPtr,
  uint32 len,
  uint32 pos
)
{
  UNUSED(len);
  
  return dataPtr[pos];
}

static inline void EC_Crypt_SetByteBE
(
  uint8 *dataPtr,
  uint32 len,
  uint8 newData,
  uint32 pos
)
{
  UNUSED(len);
  
  dataPtr[pos] = newData;
}

static inline uint8 EC_Crypt_GetByteLE
(
  const uint8 *data,
  uint32 len,
  uint32 pos
)
{
  return data[len-1-pos];
}

static inline void EC_Crypt_SetByteLE
(
  uint8 *dataPtr,
  uint32 len,
  uint8 newData,
  uint32 pos
)
{  
  dataPtr[len-1-pos] = newData;
}

static uint32 EC_Crypt_GetWord32LE
(
  const uint32 *dataPtr,
  uint32 len,
  uint32 pos
)
{
  return dataPtr[len-1-pos];
}

static void EC_Crypt_SetWord32LE
(
  uint32 *dataPtr,
  uint32 len,
  uint32 newData,
  uint32 pos
)
{
  dataPtr[len-1-pos] = newData;
}


static uint32 EC_Crypt_GetWord32BE
(
  const uint32 *dataPtr,
  uint32 len,
  uint32 pos
)
{
  UNUSED(len);

  return dataPtr[pos];
}

static void EC_Crypt_SetWord32BE
(
  uint32 *dataPtr,
  uint32 len,
  uint32 newData,
  uint32 pos
)
{
  UNUSED(len);

  dataPtr[pos] = newData;
}

static uint64 EC_Crypt_GetWord64LE
(
  const uint64 *dataPtr,
  uint32 len,
  uint32 pos
)
{
  return dataPtr[len-1-pos];
}

static void EC_Crypt_SetWord64LE
(
  uint64 *dataPtr,
  uint32 len,
  uint64 newData,
  uint32 pos
)
{
  dataPtr[len-1-pos] = newData;
}


static uint64 EC_Crypt_GetWord64BE
(
  const uint64 *dataPtr,
  uint32 len,
  uint32 pos
)
{
  UNUSED(len);

  return dataPtr[pos];
}

static void EC_Crypt_SetWord64BE
(
  uint64 *dataPtr,
  uint32 len,
  uint64 newData,
  uint32 pos
)
{
  UNUSED(len);

  dataPtr[pos] = newData;
}


static inline void EC_Crypt_XOR32
(
  void* dest, 
  const void* lhs, 
  const void* rhs
)
{
  uint32* destPtr = (uint32*) (dest);
  const uint32* lhsPtr = (const uint32*) (lhs);
  const uint32* rhsPtr = (const uint32*) (rhs);
  destPtr[0] = ((uint32) lhsPtr[0]) ^ ((uint32) rhsPtr[0]);
}

static inline void EC_Crypt_XOR64
(
  void* dest, 
  const void* lhs, 
  const void* rhs
)
{
  uint32* destPtr = (uint32*) (dest);
  const uint32* lhsPtr = (const uint32*) (lhs);
  const uint32* rhsPtr = (const uint32*) (rhs);
  destPtr[0] = ((uint32) lhsPtr[0]) ^ ((uint32) rhsPtr[0]);
  destPtr[1] = ((uint32) lhsPtr[1]) ^ ((uint32) rhsPtr[1]);
}

static inline void EC_Crypt_XOR128
(
  void* dest, 
  const void* lhs, 
  const void* rhs
)
{
  uint32* destPtr = (uint32*) (dest);
  const uint32* lhsPtr = (const uint32*) (lhs);
  const uint32* rhsPtr = (const uint32*) (rhs);
  destPtr[0] = ((uint32) lhsPtr[0]) ^ ((uint32) rhsPtr[0]);
  destPtr[1] = ((uint32) lhsPtr[1]) ^ ((uint32) rhsPtr[1]);
  destPtr[2] = ((uint32) lhsPtr[2]) ^ ((uint32) rhsPtr[2]);
  destPtr[3] = ((uint32) lhsPtr[3]) ^ ((uint32) rhsPtr[3]);
}
   
static inline uint32 EC_Crypt_NLZ32
(
	uint32 num
)
{
  /* Algorithm due to Hacker's Delight 5-11. */
  num = num | (num >> 1u);
  num = num | (num >> 2u);
  num = num | (num >> 4u);
  num = num | (num >> 8u);
  num = ~(num | (num >> 16u));
  
  /* Algorithm due to Hacker's Delight 5-2. */
  num = num - ((num >> 1u) & 0x55555555u);
  num = (num & 0x33333333u) + ((num >> 2u) & 0x33333333u);
  num = (num + (num >> 4u)) & 0x0F0F0F0Fu;
  num = num + (num >> 8u);
  num = num + (num >> 16u);
  
  return num & 0x0000003Fu;
}

static inline uint16 EC_Crypt_NLZ16
(
	uint16 num
)
{
  /* Algorithm due to Hacker's Delight 5-11. */
  num = num | (num >> 1u);
  num = num | (num >> 2u);
  num = num | (num >> 4u);
  num = ~(num | (num >> 8u));
  
  /* Algorithm due to Hacker's Delight 5-2. */
  num = num - ((num >> 1u) & 0x5555u);
  num = (num & 0x3333u) + ((num >> 2u) & 0x3333u);
  num = (num + (num >> 4u)) & 0x0F0Fu;
  num = num + (num >> 8u);
  
  return num & 0x001Fu;
}

static inline uint8 EC_Crypt_NLZ8
(
	uint8 num
)
{
  /* Algorithm due to Hacker's Delight 5-11. */
  num = num | (num >> 1u);
  num = num | (num >> 2u);
  num = ~(num | (num >> 4u));
  
  /* Algorithm due to Hacker's Delight 5-2. */
  num = num - ((num >> 1u) & 0x55u);
  num = (num & 0x33u) + ((num >> 2u) & 0x33u);
  num = (num + (num >> 4u)) & 0x0Fu;
  
  return num & 0x0Fu;
}
   
#endif /* ifndef EC_CRYPT_GENERIC_PLATFORM_CFG_H */

/*==================[end of file]===========================================*/
