<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
<#@ output extension="c" #>
/* config.c -- AUTOGENERATED -- DO NOT EDIT -- */

#include <stddef.h>
#include "pthread.h"
#include "config.h"
#include "wq.h"
#include "task.h"

<#
	foreach (XPathNavigator partition in config.Select("/system/partition"))
	{
		string part_name = partition.GetAttribute("name", "");
		string appdir;
		string null_initializer_num_tasks = "";
		string minus1_initializer_num_tasks = "";
		string task_free_initializer_num_tasks = "";
		string wq_free_initializer_num_wqs = "";


		if (!part_name.StartsWith("posix_")) {
			Console.WriteLine("Ignoring partition \"" + part_name + "\"");
		} else {
			Console.WriteLine("Processing partition \"" + part_name + "\"");
			Console.WriteLine("WARNING: Only the first POSIX partition will be processed. Be conviced, we suck intentionally.");
			// FIXME: There may be multiple POSIX partitions in a partition configuration
			// We need to match either by partition name or by application directory. Neither of them we have at hand yet.

			// check max_prio
			string max_prio = partition.GetAttribute("max_prio", "");
			if (max_prio != "255") {
				Console.WriteLine("Partition \"" + part_name + "\": max_prio attribute is invalid. Should be 255.");
				continue;
			}

			// Find "appdir" from "partition/layout/obj". This is not used any further yet. See the FIXME above.
			foreach (XPathNavigator layout in partition.Select("layout")) {
				XPathNodeIterator iterator = layout.Select("obj");
				iterator.MoveNext();
				string obj = iterator.Current.Value;
				appdir = obj.Substring(0, obj.LastIndexOf('/'));
				Console.WriteLine("Application directory for this partition is " + appdir);
				}

			// count the number of tasks in this partition. Ensure proper capabilities (blocking & timeout)
			int num_tasks = 0;

			foreach (XPathNavigator task in partition.Select("task")) {

				if ((task.GetAttribute("blocking", "") != "yes") || (task.GetAttribute("timeout", "") != "yes")) {
					// Insufficient permissions for at least one task. Stop here.
					Console.WriteLine("Insufficient capabilities for at least one task in partiiton \"" + part_name + "\". Expecting timeout & blocking");
					System.Environment.Exit(1);
				}
				num_tasks++;
			}

			int num_wqs = 0;
			foreach (XPathNavigator wq in partition.Select("wait_queue")) {

				if (wq.GetAttribute("name", "n") != wq.GetAttribute("link", "l")) {
					Console.WriteLine("At least one wait queue of partition \"" + part_name + "\" does not link to itself. Stopping.");
					System.Environment.Exit(1);
				}
				num_wqs++;
			}

			Console.WriteLine("Generating POSIX configuration for partition \"" + part_name + "\" with " + num_tasks + " tasks and " + num_wqs + " wait queues.");

			// build the iniitializer strings
			null_initializer_num_tasks = "{ ";
			minus1_initializer_num_tasks = "{ ";
			task_free_initializer_num_tasks = "{ ";
			wq_free_initializer_num_wqs = "{ ";

			for (int i = 0; i < num_tasks; i++) {
				null_initializer_num_tasks += "NULL";
				minus1_initializer_num_tasks += "-1";
				task_free_initializer_num_tasks += "TASK_FREE";
				wq_free_initializer_num_wqs += "WQ_FREE";
				if (i < num_tasks - 1) {
					null_initializer_num_tasks += ", ";
					minus1_initializer_num_tasks += ", ";
					task_free_initializer_num_tasks += ", ";
					wq_free_initializer_num_wqs += ", ";
				}
			}
			null_initializer_num_tasks += " };";
			minus1_initializer_num_tasks += "}; ";
			task_free_initializer_num_tasks += "}; ";
			wq_free_initializer_num_wqs += "}; ";


#>
	/* Stack for the main thread */
	char __stack_main[PTHREAD_STACKSIZE] __aligned(16);

	struct __pthread_config_static_str __pthread_config_static = {
		NUM_TASKS,			// num_tasks
		NUM_WQS,			// num_waitqueues
		PTHREAD_STACKSIZE,
		MAX_TIMEOUTS_PER_PRIO_INHERIT_MUTEX
	};

	void *(*__pthread_config_dynamic_pstartroutines[NUM_TASKS]) (void *) =
		<#=null_initializer_num_tasks#>
	void *__pthread_config_dynamic_pretval[NUM_TASKS] =
		<#=null_initializer_num_tasks#>
	int __pthread_config_dynamic_joinerqueues[NUM_TASKS] = 
		<#=minus1_initializer_num_tasks#>
	unsigned char __pthread_config_dynamic_btaskfree[NUM_TASKS] =
		<#=task_free_initializer_num_tasks#>
	unsigned char __pthread_config_dynamic_bwaitqueuefree[NUM_WQS] = 
		<#=wq_free_initializer_num_wqs#>

<#	
			break;
		}
	} /* foreach partition */
#>
