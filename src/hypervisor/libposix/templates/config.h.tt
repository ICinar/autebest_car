<#@ template language="C#" hostSpecific="true" debug="true" inherits="ECCG.Data.Base" #>
<#@ ECCG Processor="ECCGDirectiveProcessor" #>
<#@ output extension="h" #>
/* config.h -- AUTOGENERATED -- DO NOT EDIT -- */

#ifndef _CONFIG_H_
#define _CONFIG_H_

/* 
 Number of pthread_mutex_timedlock() calls that can be handled in parallel on 
 each mutex initialized with protocol PTHREAD_PRIO_INHERIT.
*/
#define MAX_TIMEOUTS_PER_PRIO_INHERIT_MUTEX 3

/* size of the stack of the initial task */
#define PTHREAD_STACKSIZE 1024

#define TASK_INUSE 0
#define TASK_FREE  1

#define WQ_INUSE 0
#define WQ_FREE  1



<#
	foreach (XPathNavigator partition in config.Select("/system/partition"))
	{
		string part_name = partition.GetAttribute("name", "");
		string appdir;

		if (!part_name.StartsWith("posix_")) {
			Console.WriteLine("Ignoring partition \"" + part_name + "\"");
		} else {
			Console.WriteLine("Processing partition \"" + part_name + "\"");
			Console.WriteLine("WARNING: Only the first POSIX partition will be processed. Be conviced, we suck intentionally.");
			// FIXME: There may be multiple POSIX partitions in a partition configuration
			// We need to match either by partition name or by application directory. Neither of them we have at hand yet.

			// check max_prio
			string max_prio = partition.GetAttribute("max_prio", "");
			if (max_prio != "255") {
				Console.WriteLine("Partition \"" + part_name + "\": max_prio attribute is invalid. Should be 255.");
				continue;
			}

			// Find "appdir" from "partition/layout/obj". This is not used any further yet. See the FIXME above.
			foreach (XPathNavigator layout in partition.Select("layout")) {
				XPathNodeIterator iterator = layout.Select("obj");
				iterator.MoveNext();
				string obj = iterator.Current.Value;
				appdir = obj.Substring(0, obj.LastIndexOf('/'));
				Console.WriteLine("Application directory for this partition is " + appdir);
				}

			// count the number of tasks in this partition. Ensure proper capabilities (blocking & timeout)
			int num_tasks = 0;

			foreach (XPathNavigator task in partition.Select("task")) {

				if ((task.GetAttribute("blocking", "") != "yes") || (task.GetAttribute("timeout", "") != "yes")) {
					// Insufficient permissions for at least one task. Stop here.
					Console.WriteLine("Insufficient capabilities for at least one task in partiiton \"" + part_name + "\". Expecting timeout & blocking");
					System.Environment.Exit(1);
				}
				num_tasks++;
			}

			int num_wqs = 0;
			foreach (XPathNavigator wq in partition.Select("wait_queue")) {

				if (wq.GetAttribute("name", "n") != wq.GetAttribute("link", "l")) {
					Console.WriteLine("At least one wait queue of partition \"" + part_name + "\" does not link to itself. Stopping.");
					System.Environment.Exit(1);
				}
				num_wqs++;
			}

			Console.WriteLine("Generating POSIX configuration for partition \"" + part_name + "\" with " + num_tasks + " tasks and " + num_wqs + " wait queues.");

#>

#define NUM_TASKS <#=num_tasks#>
#define NUM_WQS <#=num_wqs#>

<#	
			break;
		}
	} /* foreach partition */
#>

extern char __stack_main[] __aligned(16);

struct __pthread_config_static_str {

	const unsigned int num_tasks;
	const unsigned int num_waitqueues;
	const unsigned int initial_thread_stack_size;
	const unsigned int max_timeouts_per_prio_inherit_mutex;
};

extern void *(*__pthread_config_dynamic_pstartroutines[NUM_TASKS]) (void *);
extern void *__pthread_config_dynamic_pretval[NUM_TASKS];
extern int __pthread_config_dynamic_joinerqueues[NUM_TASKS];
extern unsigned char __pthread_config_dynamic_btaskfree[NUM_TASKS];
extern unsigned char __pthread_config_dynamic_bwaitqueuefree[NUM_WQS];

#endif
